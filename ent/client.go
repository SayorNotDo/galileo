// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"galileo/ent/migrate"

	"galileo/ent/api"
	"galileo/ent/apicategory"
	"galileo/ent/apihistory"
	"galileo/ent/apistatistics"
	"galileo/ent/apitag"
	"galileo/ent/container"
	"galileo/ent/group"
	"galileo/ent/groupmember"
	"galileo/ent/job"
	"galileo/ent/metaevent"
	"galileo/ent/project"
	"galileo/ent/projectmember"
	"galileo/ent/task"
	"galileo/ent/testcase"
	"galileo/ent/testcasesuite"
	"galileo/ent/testplan"
	"galileo/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Api is the client for interacting with the Api builders.
	Api *APIClient
	// ApiCategory is the client for interacting with the ApiCategory builders.
	ApiCategory *ApiCategoryClient
	// ApiHistory is the client for interacting with the ApiHistory builders.
	ApiHistory *ApiHistoryClient
	// ApiStatistics is the client for interacting with the ApiStatistics builders.
	ApiStatistics *ApiStatisticsClient
	// ApiTag is the client for interacting with the ApiTag builders.
	ApiTag *ApiTagClient
	// Container is the client for interacting with the Container builders.
	Container *ContainerClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// GroupMember is the client for interacting with the GroupMember builders.
	GroupMember *GroupMemberClient
	// Job is the client for interacting with the Job builders.
	Job *JobClient
	// MetaEvent is the client for interacting with the MetaEvent builders.
	MetaEvent *MetaEventClient
	// Project is the client for interacting with the Project builders.
	Project *ProjectClient
	// ProjectMember is the client for interacting with the ProjectMember builders.
	ProjectMember *ProjectMemberClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// TestPlan is the client for interacting with the TestPlan builders.
	TestPlan *TestPlanClient
	// Testcase is the client for interacting with the Testcase builders.
	Testcase *TestcaseClient
	// TestcaseSuite is the client for interacting with the TestcaseSuite builders.
	TestcaseSuite *TestcaseSuiteClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Api = NewAPIClient(c.config)
	c.ApiCategory = NewApiCategoryClient(c.config)
	c.ApiHistory = NewApiHistoryClient(c.config)
	c.ApiStatistics = NewApiStatisticsClient(c.config)
	c.ApiTag = NewApiTagClient(c.config)
	c.Container = NewContainerClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.GroupMember = NewGroupMemberClient(c.config)
	c.Job = NewJobClient(c.config)
	c.MetaEvent = NewMetaEventClient(c.config)
	c.Project = NewProjectClient(c.config)
	c.ProjectMember = NewProjectMemberClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.TestPlan = NewTestPlanClient(c.config)
	c.Testcase = NewTestcaseClient(c.config)
	c.TestcaseSuite = NewTestcaseSuiteClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Api:           NewAPIClient(cfg),
		ApiCategory:   NewApiCategoryClient(cfg),
		ApiHistory:    NewApiHistoryClient(cfg),
		ApiStatistics: NewApiStatisticsClient(cfg),
		ApiTag:        NewApiTagClient(cfg),
		Container:     NewContainerClient(cfg),
		Group:         NewGroupClient(cfg),
		GroupMember:   NewGroupMemberClient(cfg),
		Job:           NewJobClient(cfg),
		MetaEvent:     NewMetaEventClient(cfg),
		Project:       NewProjectClient(cfg),
		ProjectMember: NewProjectMemberClient(cfg),
		Task:          NewTaskClient(cfg),
		TestPlan:      NewTestPlanClient(cfg),
		Testcase:      NewTestcaseClient(cfg),
		TestcaseSuite: NewTestcaseSuiteClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:           ctx,
		config:        cfg,
		Api:           NewAPIClient(cfg),
		ApiCategory:   NewApiCategoryClient(cfg),
		ApiHistory:    NewApiHistoryClient(cfg),
		ApiStatistics: NewApiStatisticsClient(cfg),
		ApiTag:        NewApiTagClient(cfg),
		Container:     NewContainerClient(cfg),
		Group:         NewGroupClient(cfg),
		GroupMember:   NewGroupMemberClient(cfg),
		Job:           NewJobClient(cfg),
		MetaEvent:     NewMetaEventClient(cfg),
		Project:       NewProjectClient(cfg),
		ProjectMember: NewProjectMemberClient(cfg),
		Task:          NewTaskClient(cfg),
		TestPlan:      NewTestPlanClient(cfg),
		Testcase:      NewTestcaseClient(cfg),
		TestcaseSuite: NewTestcaseSuiteClient(cfg),
		User:          NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Api.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Api, c.ApiCategory, c.ApiHistory, c.ApiStatistics, c.ApiTag, c.Container,
		c.Group, c.GroupMember, c.Job, c.MetaEvent, c.Project, c.ProjectMember, c.Task,
		c.TestPlan, c.Testcase, c.TestcaseSuite, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Api, c.ApiCategory, c.ApiHistory, c.ApiStatistics, c.ApiTag, c.Container,
		c.Group, c.GroupMember, c.Job, c.MetaEvent, c.Project, c.ProjectMember, c.Task,
		c.TestPlan, c.Testcase, c.TestcaseSuite, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *APIMutation:
		return c.Api.mutate(ctx, m)
	case *ApiCategoryMutation:
		return c.ApiCategory.mutate(ctx, m)
	case *ApiHistoryMutation:
		return c.ApiHistory.mutate(ctx, m)
	case *ApiStatisticsMutation:
		return c.ApiStatistics.mutate(ctx, m)
	case *ApiTagMutation:
		return c.ApiTag.mutate(ctx, m)
	case *ContainerMutation:
		return c.Container.mutate(ctx, m)
	case *GroupMutation:
		return c.Group.mutate(ctx, m)
	case *GroupMemberMutation:
		return c.GroupMember.mutate(ctx, m)
	case *JobMutation:
		return c.Job.mutate(ctx, m)
	case *MetaEventMutation:
		return c.MetaEvent.mutate(ctx, m)
	case *ProjectMutation:
		return c.Project.mutate(ctx, m)
	case *ProjectMemberMutation:
		return c.ProjectMember.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *TestPlanMutation:
		return c.TestPlan.mutate(ctx, m)
	case *TestcaseMutation:
		return c.Testcase.mutate(ctx, m)
	case *TestcaseSuiteMutation:
		return c.TestcaseSuite.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// APIClient is a client for the Api schema.
type APIClient struct {
	config
}

// NewAPIClient returns a client for the Api from the given config.
func NewAPIClient(c config) *APIClient {
	return &APIClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `api.Hooks(f(g(h())))`.
func (c *APIClient) Use(hooks ...Hook) {
	c.hooks.Api = append(c.hooks.Api, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `api.Intercept(f(g(h())))`.
func (c *APIClient) Intercept(interceptors ...Interceptor) {
	c.inters.Api = append(c.inters.Api, interceptors...)
}

// Create returns a builder for creating a Api entity.
func (c *APIClient) Create() *APICreate {
	mutation := newAPIMutation(c.config, OpCreate)
	return &APICreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Api entities.
func (c *APIClient) CreateBulk(builders ...*APICreate) *APICreateBulk {
	return &APICreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Api.
func (c *APIClient) Update() *APIUpdate {
	mutation := newAPIMutation(c.config, OpUpdate)
	return &APIUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *APIClient) UpdateOne(a *Api) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withApi(a))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *APIClient) UpdateOneID(id int32) *APIUpdateOne {
	mutation := newAPIMutation(c.config, OpUpdateOne, withApiID(id))
	return &APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Api.
func (c *APIClient) Delete() *APIDelete {
	mutation := newAPIMutation(c.config, OpDelete)
	return &APIDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *APIClient) DeleteOne(a *Api) *APIDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *APIClient) DeleteOneID(id int32) *APIDeleteOne {
	builder := c.Delete().Where(api.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &APIDeleteOne{builder}
}

// Query returns a query builder for Api.
func (c *APIClient) Query() *APIQuery {
	return &APIQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAPI},
		inters: c.Interceptors(),
	}
}

// Get returns a Api entity by its id.
func (c *APIClient) Get(ctx context.Context, id int32) (*Api, error) {
	return c.Query().Where(api.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *APIClient) GetX(ctx context.Context, id int32) *Api {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *APIClient) Hooks() []Hook {
	return c.hooks.Api
}

// Interceptors returns the client interceptors.
func (c *APIClient) Interceptors() []Interceptor {
	return c.inters.Api
}

func (c *APIClient) mutate(ctx context.Context, m *APIMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&APICreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&APIUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&APIUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&APIDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Api mutation op: %q", m.Op())
	}
}

// ApiCategoryClient is a client for the ApiCategory schema.
type ApiCategoryClient struct {
	config
}

// NewApiCategoryClient returns a client for the ApiCategory from the given config.
func NewApiCategoryClient(c config) *ApiCategoryClient {
	return &ApiCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apicategory.Hooks(f(g(h())))`.
func (c *ApiCategoryClient) Use(hooks ...Hook) {
	c.hooks.ApiCategory = append(c.hooks.ApiCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apicategory.Intercept(f(g(h())))`.
func (c *ApiCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApiCategory = append(c.inters.ApiCategory, interceptors...)
}

// Create returns a builder for creating a ApiCategory entity.
func (c *ApiCategoryClient) Create() *ApiCategoryCreate {
	mutation := newApiCategoryMutation(c.config, OpCreate)
	return &ApiCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApiCategory entities.
func (c *ApiCategoryClient) CreateBulk(builders ...*ApiCategoryCreate) *ApiCategoryCreateBulk {
	return &ApiCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApiCategory.
func (c *ApiCategoryClient) Update() *ApiCategoryUpdate {
	mutation := newApiCategoryMutation(c.config, OpUpdate)
	return &ApiCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApiCategoryClient) UpdateOne(ac *ApiCategory) *ApiCategoryUpdateOne {
	mutation := newApiCategoryMutation(c.config, OpUpdateOne, withApiCategory(ac))
	return &ApiCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApiCategoryClient) UpdateOneID(id int) *ApiCategoryUpdateOne {
	mutation := newApiCategoryMutation(c.config, OpUpdateOne, withApiCategoryID(id))
	return &ApiCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApiCategory.
func (c *ApiCategoryClient) Delete() *ApiCategoryDelete {
	mutation := newApiCategoryMutation(c.config, OpDelete)
	return &ApiCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApiCategoryClient) DeleteOne(ac *ApiCategory) *ApiCategoryDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApiCategoryClient) DeleteOneID(id int) *ApiCategoryDeleteOne {
	builder := c.Delete().Where(apicategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApiCategoryDeleteOne{builder}
}

// Query returns a query builder for ApiCategory.
func (c *ApiCategoryClient) Query() *ApiCategoryQuery {
	return &ApiCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApiCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a ApiCategory entity by its id.
func (c *ApiCategoryClient) Get(ctx context.Context, id int) (*ApiCategory, error) {
	return c.Query().Where(apicategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApiCategoryClient) GetX(ctx context.Context, id int) *ApiCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApiCategoryClient) Hooks() []Hook {
	return c.hooks.ApiCategory
}

// Interceptors returns the client interceptors.
func (c *ApiCategoryClient) Interceptors() []Interceptor {
	return c.inters.ApiCategory
}

func (c *ApiCategoryClient) mutate(ctx context.Context, m *ApiCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApiCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApiCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApiCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApiCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApiCategory mutation op: %q", m.Op())
	}
}

// ApiHistoryClient is a client for the ApiHistory schema.
type ApiHistoryClient struct {
	config
}

// NewApiHistoryClient returns a client for the ApiHistory from the given config.
func NewApiHistoryClient(c config) *ApiHistoryClient {
	return &ApiHistoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apihistory.Hooks(f(g(h())))`.
func (c *ApiHistoryClient) Use(hooks ...Hook) {
	c.hooks.ApiHistory = append(c.hooks.ApiHistory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apihistory.Intercept(f(g(h())))`.
func (c *ApiHistoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApiHistory = append(c.inters.ApiHistory, interceptors...)
}

// Create returns a builder for creating a ApiHistory entity.
func (c *ApiHistoryClient) Create() *ApiHistoryCreate {
	mutation := newApiHistoryMutation(c.config, OpCreate)
	return &ApiHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApiHistory entities.
func (c *ApiHistoryClient) CreateBulk(builders ...*ApiHistoryCreate) *ApiHistoryCreateBulk {
	return &ApiHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApiHistory.
func (c *ApiHistoryClient) Update() *ApiHistoryUpdate {
	mutation := newApiHistoryMutation(c.config, OpUpdate)
	return &ApiHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApiHistoryClient) UpdateOne(ah *ApiHistory) *ApiHistoryUpdateOne {
	mutation := newApiHistoryMutation(c.config, OpUpdateOne, withApiHistory(ah))
	return &ApiHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApiHistoryClient) UpdateOneID(id int32) *ApiHistoryUpdateOne {
	mutation := newApiHistoryMutation(c.config, OpUpdateOne, withApiHistoryID(id))
	return &ApiHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApiHistory.
func (c *ApiHistoryClient) Delete() *ApiHistoryDelete {
	mutation := newApiHistoryMutation(c.config, OpDelete)
	return &ApiHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApiHistoryClient) DeleteOne(ah *ApiHistory) *ApiHistoryDeleteOne {
	return c.DeleteOneID(ah.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApiHistoryClient) DeleteOneID(id int32) *ApiHistoryDeleteOne {
	builder := c.Delete().Where(apihistory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApiHistoryDeleteOne{builder}
}

// Query returns a query builder for ApiHistory.
func (c *ApiHistoryClient) Query() *ApiHistoryQuery {
	return &ApiHistoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApiHistory},
		inters: c.Interceptors(),
	}
}

// Get returns a ApiHistory entity by its id.
func (c *ApiHistoryClient) Get(ctx context.Context, id int32) (*ApiHistory, error) {
	return c.Query().Where(apihistory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApiHistoryClient) GetX(ctx context.Context, id int32) *ApiHistory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApiHistoryClient) Hooks() []Hook {
	return c.hooks.ApiHistory
}

// Interceptors returns the client interceptors.
func (c *ApiHistoryClient) Interceptors() []Interceptor {
	return c.inters.ApiHistory
}

func (c *ApiHistoryClient) mutate(ctx context.Context, m *ApiHistoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApiHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApiHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApiHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApiHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApiHistory mutation op: %q", m.Op())
	}
}

// ApiStatisticsClient is a client for the ApiStatistics schema.
type ApiStatisticsClient struct {
	config
}

// NewApiStatisticsClient returns a client for the ApiStatistics from the given config.
func NewApiStatisticsClient(c config) *ApiStatisticsClient {
	return &ApiStatisticsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apistatistics.Hooks(f(g(h())))`.
func (c *ApiStatisticsClient) Use(hooks ...Hook) {
	c.hooks.ApiStatistics = append(c.hooks.ApiStatistics, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apistatistics.Intercept(f(g(h())))`.
func (c *ApiStatisticsClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApiStatistics = append(c.inters.ApiStatistics, interceptors...)
}

// Create returns a builder for creating a ApiStatistics entity.
func (c *ApiStatisticsClient) Create() *ApiStatisticsCreate {
	mutation := newApiStatisticsMutation(c.config, OpCreate)
	return &ApiStatisticsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApiStatistics entities.
func (c *ApiStatisticsClient) CreateBulk(builders ...*ApiStatisticsCreate) *ApiStatisticsCreateBulk {
	return &ApiStatisticsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApiStatistics.
func (c *ApiStatisticsClient) Update() *ApiStatisticsUpdate {
	mutation := newApiStatisticsMutation(c.config, OpUpdate)
	return &ApiStatisticsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApiStatisticsClient) UpdateOne(as *ApiStatistics) *ApiStatisticsUpdateOne {
	mutation := newApiStatisticsMutation(c.config, OpUpdateOne, withApiStatistics(as))
	return &ApiStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApiStatisticsClient) UpdateOneID(id int32) *ApiStatisticsUpdateOne {
	mutation := newApiStatisticsMutation(c.config, OpUpdateOne, withApiStatisticsID(id))
	return &ApiStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApiStatistics.
func (c *ApiStatisticsClient) Delete() *ApiStatisticsDelete {
	mutation := newApiStatisticsMutation(c.config, OpDelete)
	return &ApiStatisticsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApiStatisticsClient) DeleteOne(as *ApiStatistics) *ApiStatisticsDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApiStatisticsClient) DeleteOneID(id int32) *ApiStatisticsDeleteOne {
	builder := c.Delete().Where(apistatistics.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApiStatisticsDeleteOne{builder}
}

// Query returns a query builder for ApiStatistics.
func (c *ApiStatisticsClient) Query() *ApiStatisticsQuery {
	return &ApiStatisticsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApiStatistics},
		inters: c.Interceptors(),
	}
}

// Get returns a ApiStatistics entity by its id.
func (c *ApiStatisticsClient) Get(ctx context.Context, id int32) (*ApiStatistics, error) {
	return c.Query().Where(apistatistics.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApiStatisticsClient) GetX(ctx context.Context, id int32) *ApiStatistics {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApiStatisticsClient) Hooks() []Hook {
	return c.hooks.ApiStatistics
}

// Interceptors returns the client interceptors.
func (c *ApiStatisticsClient) Interceptors() []Interceptor {
	return c.inters.ApiStatistics
}

func (c *ApiStatisticsClient) mutate(ctx context.Context, m *ApiStatisticsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApiStatisticsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApiStatisticsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApiStatisticsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApiStatisticsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApiStatistics mutation op: %q", m.Op())
	}
}

// ApiTagClient is a client for the ApiTag schema.
type ApiTagClient struct {
	config
}

// NewApiTagClient returns a client for the ApiTag from the given config.
func NewApiTagClient(c config) *ApiTagClient {
	return &ApiTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `apitag.Hooks(f(g(h())))`.
func (c *ApiTagClient) Use(hooks ...Hook) {
	c.hooks.ApiTag = append(c.hooks.ApiTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `apitag.Intercept(f(g(h())))`.
func (c *ApiTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApiTag = append(c.inters.ApiTag, interceptors...)
}

// Create returns a builder for creating a ApiTag entity.
func (c *ApiTagClient) Create() *ApiTagCreate {
	mutation := newApiTagMutation(c.config, OpCreate)
	return &ApiTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApiTag entities.
func (c *ApiTagClient) CreateBulk(builders ...*ApiTagCreate) *ApiTagCreateBulk {
	return &ApiTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApiTag.
func (c *ApiTagClient) Update() *ApiTagUpdate {
	mutation := newApiTagMutation(c.config, OpUpdate)
	return &ApiTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApiTagClient) UpdateOne(at *ApiTag) *ApiTagUpdateOne {
	mutation := newApiTagMutation(c.config, OpUpdateOne, withApiTag(at))
	return &ApiTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApiTagClient) UpdateOneID(id int32) *ApiTagUpdateOne {
	mutation := newApiTagMutation(c.config, OpUpdateOne, withApiTagID(id))
	return &ApiTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApiTag.
func (c *ApiTagClient) Delete() *ApiTagDelete {
	mutation := newApiTagMutation(c.config, OpDelete)
	return &ApiTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApiTagClient) DeleteOne(at *ApiTag) *ApiTagDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApiTagClient) DeleteOneID(id int32) *ApiTagDeleteOne {
	builder := c.Delete().Where(apitag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApiTagDeleteOne{builder}
}

// Query returns a query builder for ApiTag.
func (c *ApiTagClient) Query() *ApiTagQuery {
	return &ApiTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApiTag},
		inters: c.Interceptors(),
	}
}

// Get returns a ApiTag entity by its id.
func (c *ApiTagClient) Get(ctx context.Context, id int32) (*ApiTag, error) {
	return c.Query().Where(apitag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApiTagClient) GetX(ctx context.Context, id int32) *ApiTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApiTagClient) Hooks() []Hook {
	return c.hooks.ApiTag
}

// Interceptors returns the client interceptors.
func (c *ApiTagClient) Interceptors() []Interceptor {
	return c.inters.ApiTag
}

func (c *ApiTagClient) mutate(ctx context.Context, m *ApiTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApiTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApiTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApiTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApiTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ApiTag mutation op: %q", m.Op())
	}
}

// ContainerClient is a client for the Container schema.
type ContainerClient struct {
	config
}

// NewContainerClient returns a client for the Container from the given config.
func NewContainerClient(c config) *ContainerClient {
	return &ContainerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `container.Hooks(f(g(h())))`.
func (c *ContainerClient) Use(hooks ...Hook) {
	c.hooks.Container = append(c.hooks.Container, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `container.Intercept(f(g(h())))`.
func (c *ContainerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Container = append(c.inters.Container, interceptors...)
}

// Create returns a builder for creating a Container entity.
func (c *ContainerClient) Create() *ContainerCreate {
	mutation := newContainerMutation(c.config, OpCreate)
	return &ContainerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Container entities.
func (c *ContainerClient) CreateBulk(builders ...*ContainerCreate) *ContainerCreateBulk {
	return &ContainerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Container.
func (c *ContainerClient) Update() *ContainerUpdate {
	mutation := newContainerMutation(c.config, OpUpdate)
	return &ContainerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContainerClient) UpdateOne(co *Container) *ContainerUpdateOne {
	mutation := newContainerMutation(c.config, OpUpdateOne, withContainer(co))
	return &ContainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContainerClient) UpdateOneID(id string) *ContainerUpdateOne {
	mutation := newContainerMutation(c.config, OpUpdateOne, withContainerID(id))
	return &ContainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Container.
func (c *ContainerClient) Delete() *ContainerDelete {
	mutation := newContainerMutation(c.config, OpDelete)
	return &ContainerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContainerClient) DeleteOne(co *Container) *ContainerDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContainerClient) DeleteOneID(id string) *ContainerDeleteOne {
	builder := c.Delete().Where(container.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContainerDeleteOne{builder}
}

// Query returns a query builder for Container.
func (c *ContainerClient) Query() *ContainerQuery {
	return &ContainerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeContainer},
		inters: c.Interceptors(),
	}
}

// Get returns a Container entity by its id.
func (c *ContainerClient) Get(ctx context.Context, id string) (*Container, error) {
	return c.Query().Where(container.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContainerClient) GetX(ctx context.Context, id string) *Container {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ContainerClient) Hooks() []Hook {
	return c.hooks.Container
}

// Interceptors returns the client interceptors.
func (c *ContainerClient) Interceptors() []Interceptor {
	return c.inters.Container
}

func (c *ContainerClient) mutate(ctx context.Context, m *ContainerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ContainerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ContainerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ContainerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ContainerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Container mutation op: %q", m.Op())
	}
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `group.Intercept(f(g(h())))`.
func (c *GroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.Group = append(c.inters.Group, interceptors...)
}

// Create returns a builder for creating a Group entity.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id int64) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupClient) DeleteOneID(id int64) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id int64) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id int64) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	return c.hooks.Group
}

// Interceptors returns the client interceptors.
func (c *GroupClient) Interceptors() []Interceptor {
	return c.inters.Group
}

func (c *GroupClient) mutate(ctx context.Context, m *GroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Group mutation op: %q", m.Op())
	}
}

// GroupMemberClient is a client for the GroupMember schema.
type GroupMemberClient struct {
	config
}

// NewGroupMemberClient returns a client for the GroupMember from the given config.
func NewGroupMemberClient(c config) *GroupMemberClient {
	return &GroupMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupmember.Hooks(f(g(h())))`.
func (c *GroupMemberClient) Use(hooks ...Hook) {
	c.hooks.GroupMember = append(c.hooks.GroupMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `groupmember.Intercept(f(g(h())))`.
func (c *GroupMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.GroupMember = append(c.inters.GroupMember, interceptors...)
}

// Create returns a builder for creating a GroupMember entity.
func (c *GroupMemberClient) Create() *GroupMemberCreate {
	mutation := newGroupMemberMutation(c.config, OpCreate)
	return &GroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GroupMember entities.
func (c *GroupMemberClient) CreateBulk(builders ...*GroupMemberCreate) *GroupMemberCreateBulk {
	return &GroupMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupMember.
func (c *GroupMemberClient) Update() *GroupMemberUpdate {
	mutation := newGroupMemberMutation(c.config, OpUpdate)
	return &GroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupMemberClient) UpdateOne(gm *GroupMember) *GroupMemberUpdateOne {
	mutation := newGroupMemberMutation(c.config, OpUpdateOne, withGroupMember(gm))
	return &GroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupMemberClient) UpdateOneID(id int64) *GroupMemberUpdateOne {
	mutation := newGroupMemberMutation(c.config, OpUpdateOne, withGroupMemberID(id))
	return &GroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupMember.
func (c *GroupMemberClient) Delete() *GroupMemberDelete {
	mutation := newGroupMemberMutation(c.config, OpDelete)
	return &GroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GroupMemberClient) DeleteOne(gm *GroupMember) *GroupMemberDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GroupMemberClient) DeleteOneID(id int64) *GroupMemberDeleteOne {
	builder := c.Delete().Where(groupmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupMemberDeleteOne{builder}
}

// Query returns a query builder for GroupMember.
func (c *GroupMemberClient) Query() *GroupMemberQuery {
	return &GroupMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGroupMember},
		inters: c.Interceptors(),
	}
}

// Get returns a GroupMember entity by its id.
func (c *GroupMemberClient) Get(ctx context.Context, id int64) (*GroupMember, error) {
	return c.Query().Where(groupmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupMemberClient) GetX(ctx context.Context, id int64) *GroupMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GroupMemberClient) Hooks() []Hook {
	return c.hooks.GroupMember
}

// Interceptors returns the client interceptors.
func (c *GroupMemberClient) Interceptors() []Interceptor {
	return c.inters.GroupMember
}

func (c *GroupMemberClient) mutate(ctx context.Context, m *GroupMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GroupMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GroupMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GroupMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GroupMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GroupMember mutation op: %q", m.Op())
	}
}

// JobClient is a client for the Job schema.
type JobClient struct {
	config
}

// NewJobClient returns a client for the Job from the given config.
func NewJobClient(c config) *JobClient {
	return &JobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `job.Hooks(f(g(h())))`.
func (c *JobClient) Use(hooks ...Hook) {
	c.hooks.Job = append(c.hooks.Job, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `job.Intercept(f(g(h())))`.
func (c *JobClient) Intercept(interceptors ...Interceptor) {
	c.inters.Job = append(c.inters.Job, interceptors...)
}

// Create returns a builder for creating a Job entity.
func (c *JobClient) Create() *JobCreate {
	mutation := newJobMutation(c.config, OpCreate)
	return &JobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Job entities.
func (c *JobClient) CreateBulk(builders ...*JobCreate) *JobCreateBulk {
	return &JobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Job.
func (c *JobClient) Update() *JobUpdate {
	mutation := newJobMutation(c.config, OpUpdate)
	return &JobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JobClient) UpdateOne(j *Job) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJob(j))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JobClient) UpdateOneID(id int64) *JobUpdateOne {
	mutation := newJobMutation(c.config, OpUpdateOne, withJobID(id))
	return &JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Job.
func (c *JobClient) Delete() *JobDelete {
	mutation := newJobMutation(c.config, OpDelete)
	return &JobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JobClient) DeleteOne(j *Job) *JobDeleteOne {
	return c.DeleteOneID(j.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JobClient) DeleteOneID(id int64) *JobDeleteOne {
	builder := c.Delete().Where(job.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JobDeleteOne{builder}
}

// Query returns a query builder for Job.
func (c *JobClient) Query() *JobQuery {
	return &JobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJob},
		inters: c.Interceptors(),
	}
}

// Get returns a Job entity by its id.
func (c *JobClient) Get(ctx context.Context, id int64) (*Job, error) {
	return c.Query().Where(job.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JobClient) GetX(ctx context.Context, id int64) *Job {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *JobClient) Hooks() []Hook {
	return c.hooks.Job
}

// Interceptors returns the client interceptors.
func (c *JobClient) Interceptors() []Interceptor {
	return c.inters.Job
}

func (c *JobClient) mutate(ctx context.Context, m *JobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Job mutation op: %q", m.Op())
	}
}

// MetaEventClient is a client for the MetaEvent schema.
type MetaEventClient struct {
	config
}

// NewMetaEventClient returns a client for the MetaEvent from the given config.
func NewMetaEventClient(c config) *MetaEventClient {
	return &MetaEventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `metaevent.Hooks(f(g(h())))`.
func (c *MetaEventClient) Use(hooks ...Hook) {
	c.hooks.MetaEvent = append(c.hooks.MetaEvent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `metaevent.Intercept(f(g(h())))`.
func (c *MetaEventClient) Intercept(interceptors ...Interceptor) {
	c.inters.MetaEvent = append(c.inters.MetaEvent, interceptors...)
}

// Create returns a builder for creating a MetaEvent entity.
func (c *MetaEventClient) Create() *MetaEventCreate {
	mutation := newMetaEventMutation(c.config, OpCreate)
	return &MetaEventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MetaEvent entities.
func (c *MetaEventClient) CreateBulk(builders ...*MetaEventCreate) *MetaEventCreateBulk {
	return &MetaEventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MetaEvent.
func (c *MetaEventClient) Update() *MetaEventUpdate {
	mutation := newMetaEventMutation(c.config, OpUpdate)
	return &MetaEventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MetaEventClient) UpdateOne(me *MetaEvent) *MetaEventUpdateOne {
	mutation := newMetaEventMutation(c.config, OpUpdateOne, withMetaEvent(me))
	return &MetaEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MetaEventClient) UpdateOneID(id int64) *MetaEventUpdateOne {
	mutation := newMetaEventMutation(c.config, OpUpdateOne, withMetaEventID(id))
	return &MetaEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MetaEvent.
func (c *MetaEventClient) Delete() *MetaEventDelete {
	mutation := newMetaEventMutation(c.config, OpDelete)
	return &MetaEventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MetaEventClient) DeleteOne(me *MetaEvent) *MetaEventDeleteOne {
	return c.DeleteOneID(me.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MetaEventClient) DeleteOneID(id int64) *MetaEventDeleteOne {
	builder := c.Delete().Where(metaevent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MetaEventDeleteOne{builder}
}

// Query returns a query builder for MetaEvent.
func (c *MetaEventClient) Query() *MetaEventQuery {
	return &MetaEventQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMetaEvent},
		inters: c.Interceptors(),
	}
}

// Get returns a MetaEvent entity by its id.
func (c *MetaEventClient) Get(ctx context.Context, id int64) (*MetaEvent, error) {
	return c.Query().Where(metaevent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MetaEventClient) GetX(ctx context.Context, id int64) *MetaEvent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MetaEventClient) Hooks() []Hook {
	return c.hooks.MetaEvent
}

// Interceptors returns the client interceptors.
func (c *MetaEventClient) Interceptors() []Interceptor {
	return c.inters.MetaEvent
}

func (c *MetaEventClient) mutate(ctx context.Context, m *MetaEventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MetaEventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MetaEventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MetaEventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MetaEventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MetaEvent mutation op: %q", m.Op())
	}
}

// ProjectClient is a client for the Project schema.
type ProjectClient struct {
	config
}

// NewProjectClient returns a client for the Project from the given config.
func NewProjectClient(c config) *ProjectClient {
	return &ProjectClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `project.Hooks(f(g(h())))`.
func (c *ProjectClient) Use(hooks ...Hook) {
	c.hooks.Project = append(c.hooks.Project, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `project.Intercept(f(g(h())))`.
func (c *ProjectClient) Intercept(interceptors ...Interceptor) {
	c.inters.Project = append(c.inters.Project, interceptors...)
}

// Create returns a builder for creating a Project entity.
func (c *ProjectClient) Create() *ProjectCreate {
	mutation := newProjectMutation(c.config, OpCreate)
	return &ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Project entities.
func (c *ProjectClient) CreateBulk(builders ...*ProjectCreate) *ProjectCreateBulk {
	return &ProjectCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Project.
func (c *ProjectClient) Update() *ProjectUpdate {
	mutation := newProjectMutation(c.config, OpUpdate)
	return &ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectClient) UpdateOne(pr *Project) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProject(pr))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectClient) UpdateOneID(id int64) *ProjectUpdateOne {
	mutation := newProjectMutation(c.config, OpUpdateOne, withProjectID(id))
	return &ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Project.
func (c *ProjectClient) Delete() *ProjectDelete {
	mutation := newProjectMutation(c.config, OpDelete)
	return &ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectClient) DeleteOne(pr *Project) *ProjectDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectClient) DeleteOneID(id int64) *ProjectDeleteOne {
	builder := c.Delete().Where(project.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectDeleteOne{builder}
}

// Query returns a query builder for Project.
func (c *ProjectClient) Query() *ProjectQuery {
	return &ProjectQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProject},
		inters: c.Interceptors(),
	}
}

// Get returns a Project entity by its id.
func (c *ProjectClient) Get(ctx context.Context, id int64) (*Project, error) {
	return c.Query().Where(project.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectClient) GetX(ctx context.Context, id int64) *Project {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProjectClient) Hooks() []Hook {
	return c.hooks.Project
}

// Interceptors returns the client interceptors.
func (c *ProjectClient) Interceptors() []Interceptor {
	return c.inters.Project
}

func (c *ProjectClient) mutate(ctx context.Context, m *ProjectMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Project mutation op: %q", m.Op())
	}
}

// ProjectMemberClient is a client for the ProjectMember schema.
type ProjectMemberClient struct {
	config
}

// NewProjectMemberClient returns a client for the ProjectMember from the given config.
func NewProjectMemberClient(c config) *ProjectMemberClient {
	return &ProjectMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `projectmember.Hooks(f(g(h())))`.
func (c *ProjectMemberClient) Use(hooks ...Hook) {
	c.hooks.ProjectMember = append(c.hooks.ProjectMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `projectmember.Intercept(f(g(h())))`.
func (c *ProjectMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProjectMember = append(c.inters.ProjectMember, interceptors...)
}

// Create returns a builder for creating a ProjectMember entity.
func (c *ProjectMemberClient) Create() *ProjectMemberCreate {
	mutation := newProjectMemberMutation(c.config, OpCreate)
	return &ProjectMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProjectMember entities.
func (c *ProjectMemberClient) CreateBulk(builders ...*ProjectMemberCreate) *ProjectMemberCreateBulk {
	return &ProjectMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProjectMember.
func (c *ProjectMemberClient) Update() *ProjectMemberUpdate {
	mutation := newProjectMemberMutation(c.config, OpUpdate)
	return &ProjectMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProjectMemberClient) UpdateOne(pm *ProjectMember) *ProjectMemberUpdateOne {
	mutation := newProjectMemberMutation(c.config, OpUpdateOne, withProjectMember(pm))
	return &ProjectMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProjectMemberClient) UpdateOneID(id int) *ProjectMemberUpdateOne {
	mutation := newProjectMemberMutation(c.config, OpUpdateOne, withProjectMemberID(id))
	return &ProjectMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProjectMember.
func (c *ProjectMemberClient) Delete() *ProjectMemberDelete {
	mutation := newProjectMemberMutation(c.config, OpDelete)
	return &ProjectMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProjectMemberClient) DeleteOne(pm *ProjectMember) *ProjectMemberDeleteOne {
	return c.DeleteOneID(pm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProjectMemberClient) DeleteOneID(id int) *ProjectMemberDeleteOne {
	builder := c.Delete().Where(projectmember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProjectMemberDeleteOne{builder}
}

// Query returns a query builder for ProjectMember.
func (c *ProjectMemberClient) Query() *ProjectMemberQuery {
	return &ProjectMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProjectMember},
		inters: c.Interceptors(),
	}
}

// Get returns a ProjectMember entity by its id.
func (c *ProjectMemberClient) Get(ctx context.Context, id int) (*ProjectMember, error) {
	return c.Query().Where(projectmember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProjectMemberClient) GetX(ctx context.Context, id int) *ProjectMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProjectMemberClient) Hooks() []Hook {
	return c.hooks.ProjectMember
}

// Interceptors returns the client interceptors.
func (c *ProjectMemberClient) Interceptors() []Interceptor {
	return c.inters.ProjectMember
}

func (c *ProjectMemberClient) mutate(ctx context.Context, m *ProjectMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProjectMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProjectMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProjectMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProjectMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProjectMember mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(t *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(t))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int64) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(t *Task) *TaskDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int64) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int64) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int64) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// TestPlanClient is a client for the TestPlan schema.
type TestPlanClient struct {
	config
}

// NewTestPlanClient returns a client for the TestPlan from the given config.
func NewTestPlanClient(c config) *TestPlanClient {
	return &TestPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testplan.Hooks(f(g(h())))`.
func (c *TestPlanClient) Use(hooks ...Hook) {
	c.hooks.TestPlan = append(c.hooks.TestPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testplan.Intercept(f(g(h())))`.
func (c *TestPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestPlan = append(c.inters.TestPlan, interceptors...)
}

// Create returns a builder for creating a TestPlan entity.
func (c *TestPlanClient) Create() *TestPlanCreate {
	mutation := newTestPlanMutation(c.config, OpCreate)
	return &TestPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestPlan entities.
func (c *TestPlanClient) CreateBulk(builders ...*TestPlanCreate) *TestPlanCreateBulk {
	return &TestPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestPlan.
func (c *TestPlanClient) Update() *TestPlanUpdate {
	mutation := newTestPlanMutation(c.config, OpUpdate)
	return &TestPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestPlanClient) UpdateOne(tp *TestPlan) *TestPlanUpdateOne {
	mutation := newTestPlanMutation(c.config, OpUpdateOne, withTestPlan(tp))
	return &TestPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestPlanClient) UpdateOneID(id int64) *TestPlanUpdateOne {
	mutation := newTestPlanMutation(c.config, OpUpdateOne, withTestPlanID(id))
	return &TestPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestPlan.
func (c *TestPlanClient) Delete() *TestPlanDelete {
	mutation := newTestPlanMutation(c.config, OpDelete)
	return &TestPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestPlanClient) DeleteOne(tp *TestPlan) *TestPlanDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestPlanClient) DeleteOneID(id int64) *TestPlanDeleteOne {
	builder := c.Delete().Where(testplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestPlanDeleteOne{builder}
}

// Query returns a query builder for TestPlan.
func (c *TestPlanClient) Query() *TestPlanQuery {
	return &TestPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a TestPlan entity by its id.
func (c *TestPlanClient) Get(ctx context.Context, id int64) (*TestPlan, error) {
	return c.Query().Where(testplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestPlanClient) GetX(ctx context.Context, id int64) *TestPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TestPlanClient) Hooks() []Hook {
	return c.hooks.TestPlan
}

// Interceptors returns the client interceptors.
func (c *TestPlanClient) Interceptors() []Interceptor {
	return c.inters.TestPlan
}

func (c *TestPlanClient) mutate(ctx context.Context, m *TestPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestPlan mutation op: %q", m.Op())
	}
}

// TestcaseClient is a client for the Testcase schema.
type TestcaseClient struct {
	config
}

// NewTestcaseClient returns a client for the Testcase from the given config.
func NewTestcaseClient(c config) *TestcaseClient {
	return &TestcaseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcase.Hooks(f(g(h())))`.
func (c *TestcaseClient) Use(hooks ...Hook) {
	c.hooks.Testcase = append(c.hooks.Testcase, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testcase.Intercept(f(g(h())))`.
func (c *TestcaseClient) Intercept(interceptors ...Interceptor) {
	c.inters.Testcase = append(c.inters.Testcase, interceptors...)
}

// Create returns a builder for creating a Testcase entity.
func (c *TestcaseClient) Create() *TestcaseCreate {
	mutation := newTestcaseMutation(c.config, OpCreate)
	return &TestcaseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Testcase entities.
func (c *TestcaseClient) CreateBulk(builders ...*TestcaseCreate) *TestcaseCreateBulk {
	return &TestcaseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Testcase.
func (c *TestcaseClient) Update() *TestcaseUpdate {
	mutation := newTestcaseMutation(c.config, OpUpdate)
	return &TestcaseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestcaseClient) UpdateOne(t *Testcase) *TestcaseUpdateOne {
	mutation := newTestcaseMutation(c.config, OpUpdateOne, withTestcase(t))
	return &TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestcaseClient) UpdateOneID(id int32) *TestcaseUpdateOne {
	mutation := newTestcaseMutation(c.config, OpUpdateOne, withTestcaseID(id))
	return &TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Testcase.
func (c *TestcaseClient) Delete() *TestcaseDelete {
	mutation := newTestcaseMutation(c.config, OpDelete)
	return &TestcaseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestcaseClient) DeleteOne(t *Testcase) *TestcaseDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestcaseClient) DeleteOneID(id int32) *TestcaseDeleteOne {
	builder := c.Delete().Where(testcase.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestcaseDeleteOne{builder}
}

// Query returns a query builder for Testcase.
func (c *TestcaseClient) Query() *TestcaseQuery {
	return &TestcaseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestcase},
		inters: c.Interceptors(),
	}
}

// Get returns a Testcase entity by its id.
func (c *TestcaseClient) Get(ctx context.Context, id int32) (*Testcase, error) {
	return c.Query().Where(testcase.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestcaseClient) GetX(ctx context.Context, id int32) *Testcase {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TestcaseClient) Hooks() []Hook {
	return c.hooks.Testcase
}

// Interceptors returns the client interceptors.
func (c *TestcaseClient) Interceptors() []Interceptor {
	return c.inters.Testcase
}

func (c *TestcaseClient) mutate(ctx context.Context, m *TestcaseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestcaseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestcaseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestcaseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestcaseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Testcase mutation op: %q", m.Op())
	}
}

// TestcaseSuiteClient is a client for the TestcaseSuite schema.
type TestcaseSuiteClient struct {
	config
}

// NewTestcaseSuiteClient returns a client for the TestcaseSuite from the given config.
func NewTestcaseSuiteClient(c config) *TestcaseSuiteClient {
	return &TestcaseSuiteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `testcasesuite.Hooks(f(g(h())))`.
func (c *TestcaseSuiteClient) Use(hooks ...Hook) {
	c.hooks.TestcaseSuite = append(c.hooks.TestcaseSuite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `testcasesuite.Intercept(f(g(h())))`.
func (c *TestcaseSuiteClient) Intercept(interceptors ...Interceptor) {
	c.inters.TestcaseSuite = append(c.inters.TestcaseSuite, interceptors...)
}

// Create returns a builder for creating a TestcaseSuite entity.
func (c *TestcaseSuiteClient) Create() *TestcaseSuiteCreate {
	mutation := newTestcaseSuiteMutation(c.config, OpCreate)
	return &TestcaseSuiteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TestcaseSuite entities.
func (c *TestcaseSuiteClient) CreateBulk(builders ...*TestcaseSuiteCreate) *TestcaseSuiteCreateBulk {
	return &TestcaseSuiteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TestcaseSuite.
func (c *TestcaseSuiteClient) Update() *TestcaseSuiteUpdate {
	mutation := newTestcaseSuiteMutation(c.config, OpUpdate)
	return &TestcaseSuiteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TestcaseSuiteClient) UpdateOne(ts *TestcaseSuite) *TestcaseSuiteUpdateOne {
	mutation := newTestcaseSuiteMutation(c.config, OpUpdateOne, withTestcaseSuite(ts))
	return &TestcaseSuiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TestcaseSuiteClient) UpdateOneID(id int32) *TestcaseSuiteUpdateOne {
	mutation := newTestcaseSuiteMutation(c.config, OpUpdateOne, withTestcaseSuiteID(id))
	return &TestcaseSuiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TestcaseSuite.
func (c *TestcaseSuiteClient) Delete() *TestcaseSuiteDelete {
	mutation := newTestcaseSuiteMutation(c.config, OpDelete)
	return &TestcaseSuiteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TestcaseSuiteClient) DeleteOne(ts *TestcaseSuite) *TestcaseSuiteDeleteOne {
	return c.DeleteOneID(ts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TestcaseSuiteClient) DeleteOneID(id int32) *TestcaseSuiteDeleteOne {
	builder := c.Delete().Where(testcasesuite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TestcaseSuiteDeleteOne{builder}
}

// Query returns a query builder for TestcaseSuite.
func (c *TestcaseSuiteClient) Query() *TestcaseSuiteQuery {
	return &TestcaseSuiteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTestcaseSuite},
		inters: c.Interceptors(),
	}
}

// Get returns a TestcaseSuite entity by its id.
func (c *TestcaseSuiteClient) Get(ctx context.Context, id int32) (*TestcaseSuite, error) {
	return c.Query().Where(testcasesuite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TestcaseSuiteClient) GetX(ctx context.Context, id int32) *TestcaseSuite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TestcaseSuiteClient) Hooks() []Hook {
	return c.hooks.TestcaseSuite
}

// Interceptors returns the client interceptors.
func (c *TestcaseSuiteClient) Interceptors() []Interceptor {
	return c.inters.TestcaseSuite
}

func (c *TestcaseSuiteClient) mutate(ctx context.Context, m *TestcaseSuiteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TestcaseSuiteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TestcaseSuiteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TestcaseSuiteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TestcaseSuiteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TestcaseSuite mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint32) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint32) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint32) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint32) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Api, ApiCategory, ApiHistory, ApiStatistics, ApiTag, Container, Group,
		GroupMember, Job, MetaEvent, Project, ProjectMember, Task, TestPlan, Testcase,
		TestcaseSuite, User []ent.Hook
	}
	inters struct {
		Api, ApiCategory, ApiHistory, ApiStatistics, ApiTag, Container, Group,
		GroupMember, Job, MetaEvent, Project, ProjectMember, Task, TestPlan, Testcase,
		TestcaseSuite, User []ent.Interceptor
	}
)
