// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"galileo/ent/api"
	"galileo/ent/apihistory"
	"galileo/ent/apistatistics"
	"galileo/ent/apitag"
	"galileo/ent/container"
	"galileo/ent/group"
	"galileo/ent/groupmember"
	"galileo/ent/job"
	"galileo/ent/metaevent"
	"galileo/ent/predicate"
	"galileo/ent/project"
	"galileo/ent/projectmember"
	"galileo/ent/task"
	"galileo/ent/testcase"
	"galileo/ent/testcasesuite"
	"galileo/ent/testplan"
	"galileo/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI           = "Api"
	TypeApiCategory   = "ApiCategory"
	TypeApiHistory    = "ApiHistory"
	TypeApiStatistics = "ApiStatistics"
	TypeApiTag        = "ApiTag"
	TypeContainer     = "Container"
	TypeGroup         = "Group"
	TypeGroupMember   = "GroupMember"
	TypeJob           = "Job"
	TypeMetaEvent     = "MetaEvent"
	TypeProject       = "Project"
	TypeProjectMember = "ProjectMember"
	TypeTask          = "Task"
	TypeTestPlan      = "TestPlan"
	TypeTestcase      = "Testcase"
	TypeTestcaseSuite = "TestcaseSuite"
	TypeUser          = "User"
)

// APIMutation represents an operation that mutates the Api nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	name          *string
	url           *string
	_type         *int8
	add_type      *int8
	status        *int8
	addstatus     *int8
	headers       *string
	body          *string
	label         *string
	query_params  *string
	response      *string
	module        *string
	description   *string
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	include_files *string
	update_at     *time.Time
	update_by     *uint32
	addupdate_by  *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Api, error)
	predicates    []predicate.Api
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the Api entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiID sets the ID field of the mutation.
func withApiID(id int32) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *Api
		)
		m.oldValue = func(ctx context.Context) (*Api, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Api.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApi sets the old Api of the mutation.
func withApi(node *Api) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*Api, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Api entities.
func (m *APIMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Api.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *APIMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *APIMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *APIMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *APIMutation) ResetURL() {
	m.url = nil
}

// SetType sets the "type" field.
func (m *APIMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *APIMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *APIMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *APIMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *APIMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the "status" field.
func (m *APIMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *APIMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *APIMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *APIMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *APIMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetHeaders sets the "headers" field.
func (m *APIMutation) SetHeaders(s string) {
	m.headers = &s
}

// Headers returns the value of the "headers" field in the mutation.
func (m *APIMutation) Headers() (r string, exists bool) {
	v := m.headers
	if v == nil {
		return
	}
	return *v, true
}

// OldHeaders returns the old "headers" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldHeaders(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeaders: %w", err)
	}
	return oldValue.Headers, nil
}

// ClearHeaders clears the value of the "headers" field.
func (m *APIMutation) ClearHeaders() {
	m.headers = nil
	m.clearedFields[api.FieldHeaders] = struct{}{}
}

// HeadersCleared returns if the "headers" field was cleared in this mutation.
func (m *APIMutation) HeadersCleared() bool {
	_, ok := m.clearedFields[api.FieldHeaders]
	return ok
}

// ResetHeaders resets all changes to the "headers" field.
func (m *APIMutation) ResetHeaders() {
	m.headers = nil
	delete(m.clearedFields, api.FieldHeaders)
}

// SetBody sets the "body" field.
func (m *APIMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *APIMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *APIMutation) ClearBody() {
	m.body = nil
	m.clearedFields[api.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *APIMutation) BodyCleared() bool {
	_, ok := m.clearedFields[api.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *APIMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, api.FieldBody)
}

// SetLabel sets the "label" field.
func (m *APIMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *APIMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ClearLabel clears the value of the "label" field.
func (m *APIMutation) ClearLabel() {
	m.label = nil
	m.clearedFields[api.FieldLabel] = struct{}{}
}

// LabelCleared returns if the "label" field was cleared in this mutation.
func (m *APIMutation) LabelCleared() bool {
	_, ok := m.clearedFields[api.FieldLabel]
	return ok
}

// ResetLabel resets all changes to the "label" field.
func (m *APIMutation) ResetLabel() {
	m.label = nil
	delete(m.clearedFields, api.FieldLabel)
}

// SetQueryParams sets the "query_params" field.
func (m *APIMutation) SetQueryParams(s string) {
	m.query_params = &s
}

// QueryParams returns the value of the "query_params" field in the mutation.
func (m *APIMutation) QueryParams() (r string, exists bool) {
	v := m.query_params
	if v == nil {
		return
	}
	return *v, true
}

// OldQueryParams returns the old "query_params" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldQueryParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueryParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueryParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueryParams: %w", err)
	}
	return oldValue.QueryParams, nil
}

// ClearQueryParams clears the value of the "query_params" field.
func (m *APIMutation) ClearQueryParams() {
	m.query_params = nil
	m.clearedFields[api.FieldQueryParams] = struct{}{}
}

// QueryParamsCleared returns if the "query_params" field was cleared in this mutation.
func (m *APIMutation) QueryParamsCleared() bool {
	_, ok := m.clearedFields[api.FieldQueryParams]
	return ok
}

// ResetQueryParams resets all changes to the "query_params" field.
func (m *APIMutation) ResetQueryParams() {
	m.query_params = nil
	delete(m.clearedFields, api.FieldQueryParams)
}

// SetResponse sets the "response" field.
func (m *APIMutation) SetResponse(s string) {
	m.response = &s
}

// Response returns the value of the "response" field in the mutation.
func (m *APIMutation) Response() (r string, exists bool) {
	v := m.response
	if v == nil {
		return
	}
	return *v, true
}

// OldResponse returns the old "response" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldResponse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponse: %w", err)
	}
	return oldValue.Response, nil
}

// ClearResponse clears the value of the "response" field.
func (m *APIMutation) ClearResponse() {
	m.response = nil
	m.clearedFields[api.FieldResponse] = struct{}{}
}

// ResponseCleared returns if the "response" field was cleared in this mutation.
func (m *APIMutation) ResponseCleared() bool {
	_, ok := m.clearedFields[api.FieldResponse]
	return ok
}

// ResetResponse resets all changes to the "response" field.
func (m *APIMutation) ResetResponse() {
	m.response = nil
	delete(m.clearedFields, api.FieldResponse)
}

// SetModule sets the "module" field.
func (m *APIMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *APIMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ClearModule clears the value of the "module" field.
func (m *APIMutation) ClearModule() {
	m.module = nil
	m.clearedFields[api.FieldModule] = struct{}{}
}

// ModuleCleared returns if the "module" field was cleared in this mutation.
func (m *APIMutation) ModuleCleared() bool {
	_, ok := m.clearedFields[api.FieldModule]
	return ok
}

// ResetModule resets all changes to the "module" field.
func (m *APIMutation) ResetModule() {
	m.module = nil
	delete(m.clearedFields, api.FieldModule)
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *APIMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[api.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *APIMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[api.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, api.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *APIMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *APIMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *APIMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *APIMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *APIMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetIncludeFiles sets the "include_files" field.
func (m *APIMutation) SetIncludeFiles(s string) {
	m.include_files = &s
}

// IncludeFiles returns the value of the "include_files" field in the mutation.
func (m *APIMutation) IncludeFiles() (r string, exists bool) {
	v := m.include_files
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludeFiles returns the old "include_files" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldIncludeFiles(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludeFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludeFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludeFiles: %w", err)
	}
	return oldValue.IncludeFiles, nil
}

// ClearIncludeFiles clears the value of the "include_files" field.
func (m *APIMutation) ClearIncludeFiles() {
	m.include_files = nil
	m.clearedFields[api.FieldIncludeFiles] = struct{}{}
}

// IncludeFilesCleared returns if the "include_files" field was cleared in this mutation.
func (m *APIMutation) IncludeFilesCleared() bool {
	_, ok := m.clearedFields[api.FieldIncludeFiles]
	return ok
}

// ResetIncludeFiles resets all changes to the "include_files" field.
func (m *APIMutation) ResetIncludeFiles() {
	m.include_files = nil
	delete(m.clearedFields, api.FieldIncludeFiles)
}

// SetUpdateAt sets the "update_at" field.
func (m *APIMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *APIMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ClearUpdateAt clears the value of the "update_at" field.
func (m *APIMutation) ClearUpdateAt() {
	m.update_at = nil
	m.clearedFields[api.FieldUpdateAt] = struct{}{}
}

// UpdateAtCleared returns if the "update_at" field was cleared in this mutation.
func (m *APIMutation) UpdateAtCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdateAt]
	return ok
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *APIMutation) ResetUpdateAt() {
	m.update_at = nil
	delete(m.clearedFields, api.FieldUpdateAt)
}

// SetUpdateBy sets the "update_by" field.
func (m *APIMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *APIMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdateBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *APIMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *APIMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *APIMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[api.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *APIMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[api.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *APIMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, api.FieldUpdateBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APIMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[api.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APIMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[api.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, api.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *APIMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *APIMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Api entity.
// If the Api object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *APIMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *APIMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *APIMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[api.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *APIMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[api.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *APIMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, api.FieldDeletedBy)
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.Api) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Api, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Api).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, api.FieldName)
	}
	if m.url != nil {
		fields = append(fields, api.FieldURL)
	}
	if m._type != nil {
		fields = append(fields, api.FieldType)
	}
	if m.status != nil {
		fields = append(fields, api.FieldStatus)
	}
	if m.headers != nil {
		fields = append(fields, api.FieldHeaders)
	}
	if m.body != nil {
		fields = append(fields, api.FieldBody)
	}
	if m.label != nil {
		fields = append(fields, api.FieldLabel)
	}
	if m.query_params != nil {
		fields = append(fields, api.FieldQueryParams)
	}
	if m.response != nil {
		fields = append(fields, api.FieldResponse)
	}
	if m.module != nil {
		fields = append(fields, api.FieldModule)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, api.FieldCreatedBy)
	}
	if m.include_files != nil {
		fields = append(fields, api.FieldIncludeFiles)
	}
	if m.update_at != nil {
		fields = append(fields, api.FieldUpdateAt)
	}
	if m.update_by != nil {
		fields = append(fields, api.FieldUpdateBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, api.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, api.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldName:
		return m.Name()
	case api.FieldURL:
		return m.URL()
	case api.FieldType:
		return m.GetType()
	case api.FieldStatus:
		return m.Status()
	case api.FieldHeaders:
		return m.Headers()
	case api.FieldBody:
		return m.Body()
	case api.FieldLabel:
		return m.Label()
	case api.FieldQueryParams:
		return m.QueryParams()
	case api.FieldResponse:
		return m.Response()
	case api.FieldModule:
		return m.Module()
	case api.FieldDescription:
		return m.Description()
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldCreatedBy:
		return m.CreatedBy()
	case api.FieldIncludeFiles:
		return m.IncludeFiles()
	case api.FieldUpdateAt:
		return m.UpdateAt()
	case api.FieldUpdateBy:
		return m.UpdateBy()
	case api.FieldDeletedAt:
		return m.DeletedAt()
	case api.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldName:
		return m.OldName(ctx)
	case api.FieldURL:
		return m.OldURL(ctx)
	case api.FieldType:
		return m.OldType(ctx)
	case api.FieldStatus:
		return m.OldStatus(ctx)
	case api.FieldHeaders:
		return m.OldHeaders(ctx)
	case api.FieldBody:
		return m.OldBody(ctx)
	case api.FieldLabel:
		return m.OldLabel(ctx)
	case api.FieldQueryParams:
		return m.OldQueryParams(ctx)
	case api.FieldResponse:
		return m.OldResponse(ctx)
	case api.FieldModule:
		return m.OldModule(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case api.FieldIncludeFiles:
		return m.OldIncludeFiles(ctx)
	case api.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case api.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case api.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case api.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown Api field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case api.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case api.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case api.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case api.FieldHeaders:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeaders(v)
		return nil
	case api.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case api.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case api.FieldQueryParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueryParams(v)
		return nil
	case api.FieldResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponse(v)
		return nil
	case api.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case api.FieldIncludeFiles:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludeFiles(v)
		return nil
	case api.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case api.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case api.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case api.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Api field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, api.FieldType)
	}
	if m.addstatus != nil {
		fields = append(fields, api.FieldStatus)
	}
	if m.addcreated_by != nil {
		fields = append(fields, api.FieldCreatedBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, api.FieldUpdateBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, api.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldType:
		return m.AddedType()
	case api.FieldStatus:
		return m.AddedStatus()
	case api.FieldCreatedBy:
		return m.AddedCreatedBy()
	case api.FieldUpdateBy:
		return m.AddedUpdateBy()
	case api.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case api.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case api.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case api.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case api.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Api numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldHeaders) {
		fields = append(fields, api.FieldHeaders)
	}
	if m.FieldCleared(api.FieldBody) {
		fields = append(fields, api.FieldBody)
	}
	if m.FieldCleared(api.FieldLabel) {
		fields = append(fields, api.FieldLabel)
	}
	if m.FieldCleared(api.FieldQueryParams) {
		fields = append(fields, api.FieldQueryParams)
	}
	if m.FieldCleared(api.FieldResponse) {
		fields = append(fields, api.FieldResponse)
	}
	if m.FieldCleared(api.FieldModule) {
		fields = append(fields, api.FieldModule)
	}
	if m.FieldCleared(api.FieldDescription) {
		fields = append(fields, api.FieldDescription)
	}
	if m.FieldCleared(api.FieldIncludeFiles) {
		fields = append(fields, api.FieldIncludeFiles)
	}
	if m.FieldCleared(api.FieldUpdateAt) {
		fields = append(fields, api.FieldUpdateAt)
	}
	if m.FieldCleared(api.FieldUpdateBy) {
		fields = append(fields, api.FieldUpdateBy)
	}
	if m.FieldCleared(api.FieldDeletedAt) {
		fields = append(fields, api.FieldDeletedAt)
	}
	if m.FieldCleared(api.FieldDeletedBy) {
		fields = append(fields, api.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldHeaders:
		m.ClearHeaders()
		return nil
	case api.FieldBody:
		m.ClearBody()
		return nil
	case api.FieldLabel:
		m.ClearLabel()
		return nil
	case api.FieldQueryParams:
		m.ClearQueryParams()
		return nil
	case api.FieldResponse:
		m.ClearResponse()
		return nil
	case api.FieldModule:
		m.ClearModule()
		return nil
	case api.FieldDescription:
		m.ClearDescription()
		return nil
	case api.FieldIncludeFiles:
		m.ClearIncludeFiles()
		return nil
	case api.FieldUpdateAt:
		m.ClearUpdateAt()
		return nil
	case api.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case api.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case api.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Api nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldName:
		m.ResetName()
		return nil
	case api.FieldURL:
		m.ResetURL()
		return nil
	case api.FieldType:
		m.ResetType()
		return nil
	case api.FieldStatus:
		m.ResetStatus()
		return nil
	case api.FieldHeaders:
		m.ResetHeaders()
		return nil
	case api.FieldBody:
		m.ResetBody()
		return nil
	case api.FieldLabel:
		m.ResetLabel()
		return nil
	case api.FieldQueryParams:
		m.ResetQueryParams()
		return nil
	case api.FieldResponse:
		m.ResetResponse()
		return nil
	case api.FieldModule:
		m.ResetModule()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case api.FieldIncludeFiles:
		m.ResetIncludeFiles()
		return nil
	case api.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case api.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case api.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case api.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Api field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Api unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Api edge %s", name)
}

// ApiCategoryMutation represents an operation that mutates the ApiCategory nodes in the graph.
type ApiCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiCategory, error)
	predicates    []predicate.ApiCategory
}

var _ ent.Mutation = (*ApiCategoryMutation)(nil)

// apicategoryOption allows management of the mutation configuration using functional options.
type apicategoryOption func(*ApiCategoryMutation)

// newApiCategoryMutation creates new mutation for the ApiCategory entity.
func newApiCategoryMutation(c config, op Op, opts ...apicategoryOption) *ApiCategoryMutation {
	m := &ApiCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeApiCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiCategoryID sets the ID field of the mutation.
func withApiCategoryID(id int) apicategoryOption {
	return func(m *ApiCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiCategory
		)
		m.oldValue = func(ctx context.Context) (*ApiCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiCategory sets the old ApiCategory of the mutation.
func withApiCategory(node *ApiCategory) apicategoryOption {
	return func(m *ApiCategoryMutation) {
		m.oldValue = func(context.Context) (*ApiCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the ApiCategoryMutation builder.
func (m *ApiCategoryMutation) Where(ps ...predicate.ApiCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiCategory).
func (m *ApiCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiCategoryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiCategoryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ApiCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiCategoryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ApiCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiCategoryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ApiCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiCategory edge %s", name)
}

// ApiHistoryMutation represents an operation that mutates the ApiHistory nodes in the graph.
type ApiHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	version       *int32
	addversion    *int32
	query_params  *string
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiHistory, error)
	predicates    []predicate.ApiHistory
}

var _ ent.Mutation = (*ApiHistoryMutation)(nil)

// apihistoryOption allows management of the mutation configuration using functional options.
type apihistoryOption func(*ApiHistoryMutation)

// newApiHistoryMutation creates new mutation for the ApiHistory entity.
func newApiHistoryMutation(c config, op Op, opts ...apihistoryOption) *ApiHistoryMutation {
	m := &ApiHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeApiHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiHistoryID sets the ID field of the mutation.
func withApiHistoryID(id int32) apihistoryOption {
	return func(m *ApiHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiHistory
		)
		m.oldValue = func(ctx context.Context) (*ApiHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiHistory sets the old ApiHistory of the mutation.
func withApiHistory(node *ApiHistory) apihistoryOption {
	return func(m *ApiHistoryMutation) {
		m.oldValue = func(context.Context) (*ApiHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiHistory entities.
func (m *ApiHistoryMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiHistoryMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiHistoryMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *ApiHistoryMutation) SetVersion(i int32) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ApiHistoryMutation) Version() (r int32, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ApiHistory entity.
// If the ApiHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiHistoryMutation) OldVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ApiHistoryMutation) AddVersion(i int32) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ApiHistoryMutation) AddedVersion() (r int32, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ApiHistoryMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetQueryParams sets the "query_params" field.
func (m *ApiHistoryMutation) SetQueryParams(s string) {
	m.query_params = &s
}

// QueryParams returns the value of the "query_params" field in the mutation.
func (m *ApiHistoryMutation) QueryParams() (r string, exists bool) {
	v := m.query_params
	if v == nil {
		return
	}
	return *v, true
}

// OldQueryParams returns the old "query_params" field's value of the ApiHistory entity.
// If the ApiHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiHistoryMutation) OldQueryParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueryParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueryParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueryParams: %w", err)
	}
	return oldValue.QueryParams, nil
}

// ResetQueryParams resets all changes to the "query_params" field.
func (m *ApiHistoryMutation) ResetQueryParams() {
	m.query_params = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiHistory entity.
// If the ApiHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ApiHistoryMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ApiHistoryMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ApiHistory entity.
// If the ApiHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiHistoryMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *ApiHistoryMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ApiHistoryMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ApiHistoryMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetDescription sets the "description" field.
func (m *ApiHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApiHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ApiHistory entity.
// If the ApiHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ApiHistoryMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the ApiHistoryMutation builder.
func (m *ApiHistoryMutation) Where(ps ...predicate.ApiHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiHistory).
func (m *ApiHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiHistoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.version != nil {
		fields = append(fields, apihistory.FieldVersion)
	}
	if m.query_params != nil {
		fields = append(fields, apihistory.FieldQueryParams)
	}
	if m.created_at != nil {
		fields = append(fields, apihistory.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, apihistory.FieldCreatedBy)
	}
	if m.description != nil {
		fields = append(fields, apihistory.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apihistory.FieldVersion:
		return m.Version()
	case apihistory.FieldQueryParams:
		return m.QueryParams()
	case apihistory.FieldCreatedAt:
		return m.CreatedAt()
	case apihistory.FieldCreatedBy:
		return m.CreatedBy()
	case apihistory.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apihistory.FieldVersion:
		return m.OldVersion(ctx)
	case apihistory.FieldQueryParams:
		return m.OldQueryParams(ctx)
	case apihistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apihistory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apihistory.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ApiHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apihistory.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case apihistory.FieldQueryParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueryParams(v)
		return nil
	case apihistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apihistory.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apihistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ApiHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, apihistory.FieldVersion)
	}
	if m.addcreated_by != nil {
		fields = append(fields, apihistory.FieldCreatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apihistory.FieldVersion:
		return m.AddedVersion()
	case apihistory.FieldCreatedBy:
		return m.AddedCreatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apihistory.FieldVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case apihistory.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ApiHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiHistoryMutation) ResetField(name string) error {
	switch name {
	case apihistory.FieldVersion:
		m.ResetVersion()
		return nil
	case apihistory.FieldQueryParams:
		m.ResetQueryParams()
		return nil
	case apihistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apihistory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apihistory.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ApiHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiHistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiHistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiHistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiHistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiHistory edge %s", name)
}

// ApiStatisticsMutation represents an operation that mutates the ApiStatistics nodes in the graph.
type ApiStatisticsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	call_count           *int32
	addcall_count        *int32
	success_count        *int32
	addsuccess_count     *int32
	failure_count        *int32
	addfailure_count     *int32
	avg_response_time    *float64
	addavg_response_time *float64
	max_response_time    *float64
	addmax_response_time *float64
	min_response_time    *float64
	addmin_response_time *float64
	avg_traffic          *float64
	addavg_traffic       *float64
	max_traffic          *float64
	addmax_traffic       *float64
	min_traffic          *float64
	addmin_traffic       *float64
	description          *string
	created_at           *time.Time
	update_at            *time.Time
	api_id               *int32
	addapi_id            *int32
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ApiStatistics, error)
	predicates           []predicate.ApiStatistics
}

var _ ent.Mutation = (*ApiStatisticsMutation)(nil)

// apistatisticsOption allows management of the mutation configuration using functional options.
type apistatisticsOption func(*ApiStatisticsMutation)

// newApiStatisticsMutation creates new mutation for the ApiStatistics entity.
func newApiStatisticsMutation(c config, op Op, opts ...apistatisticsOption) *ApiStatisticsMutation {
	m := &ApiStatisticsMutation{
		config:        c,
		op:            op,
		typ:           TypeApiStatistics,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiStatisticsID sets the ID field of the mutation.
func withApiStatisticsID(id int32) apistatisticsOption {
	return func(m *ApiStatisticsMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiStatistics
		)
		m.oldValue = func(ctx context.Context) (*ApiStatistics, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiStatistics.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiStatistics sets the old ApiStatistics of the mutation.
func withApiStatistics(node *ApiStatistics) apistatisticsOption {
	return func(m *ApiStatisticsMutation) {
		m.oldValue = func(context.Context) (*ApiStatistics, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiStatisticsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiStatisticsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiStatistics entities.
func (m *ApiStatisticsMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiStatisticsMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiStatisticsMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiStatistics.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallCount sets the "call_count" field.
func (m *ApiStatisticsMutation) SetCallCount(i int32) {
	m.call_count = &i
	m.addcall_count = nil
}

// CallCount returns the value of the "call_count" field in the mutation.
func (m *ApiStatisticsMutation) CallCount() (r int32, exists bool) {
	v := m.call_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCallCount returns the old "call_count" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldCallCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallCount: %w", err)
	}
	return oldValue.CallCount, nil
}

// AddCallCount adds i to the "call_count" field.
func (m *ApiStatisticsMutation) AddCallCount(i int32) {
	if m.addcall_count != nil {
		*m.addcall_count += i
	} else {
		m.addcall_count = &i
	}
}

// AddedCallCount returns the value that was added to the "call_count" field in this mutation.
func (m *ApiStatisticsMutation) AddedCallCount() (r int32, exists bool) {
	v := m.addcall_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCallCount resets all changes to the "call_count" field.
func (m *ApiStatisticsMutation) ResetCallCount() {
	m.call_count = nil
	m.addcall_count = nil
}

// SetSuccessCount sets the "success_count" field.
func (m *ApiStatisticsMutation) SetSuccessCount(i int32) {
	m.success_count = &i
	m.addsuccess_count = nil
}

// SuccessCount returns the value of the "success_count" field in the mutation.
func (m *ApiStatisticsMutation) SuccessCount() (r int32, exists bool) {
	v := m.success_count
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessCount returns the old "success_count" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldSuccessCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessCount: %w", err)
	}
	return oldValue.SuccessCount, nil
}

// AddSuccessCount adds i to the "success_count" field.
func (m *ApiStatisticsMutation) AddSuccessCount(i int32) {
	if m.addsuccess_count != nil {
		*m.addsuccess_count += i
	} else {
		m.addsuccess_count = &i
	}
}

// AddedSuccessCount returns the value that was added to the "success_count" field in this mutation.
func (m *ApiStatisticsMutation) AddedSuccessCount() (r int32, exists bool) {
	v := m.addsuccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuccessCount resets all changes to the "success_count" field.
func (m *ApiStatisticsMutation) ResetSuccessCount() {
	m.success_count = nil
	m.addsuccess_count = nil
}

// SetFailureCount sets the "failure_count" field.
func (m *ApiStatisticsMutation) SetFailureCount(i int32) {
	m.failure_count = &i
	m.addfailure_count = nil
}

// FailureCount returns the value of the "failure_count" field in the mutation.
func (m *ApiStatisticsMutation) FailureCount() (r int32, exists bool) {
	v := m.failure_count
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureCount returns the old "failure_count" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldFailureCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureCount: %w", err)
	}
	return oldValue.FailureCount, nil
}

// AddFailureCount adds i to the "failure_count" field.
func (m *ApiStatisticsMutation) AddFailureCount(i int32) {
	if m.addfailure_count != nil {
		*m.addfailure_count += i
	} else {
		m.addfailure_count = &i
	}
}

// AddedFailureCount returns the value that was added to the "failure_count" field in this mutation.
func (m *ApiStatisticsMutation) AddedFailureCount() (r int32, exists bool) {
	v := m.addfailure_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetFailureCount resets all changes to the "failure_count" field.
func (m *ApiStatisticsMutation) ResetFailureCount() {
	m.failure_count = nil
	m.addfailure_count = nil
}

// SetAvgResponseTime sets the "avg_response_time" field.
func (m *ApiStatisticsMutation) SetAvgResponseTime(f float64) {
	m.avg_response_time = &f
	m.addavg_response_time = nil
}

// AvgResponseTime returns the value of the "avg_response_time" field in the mutation.
func (m *ApiStatisticsMutation) AvgResponseTime() (r float64, exists bool) {
	v := m.avg_response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgResponseTime returns the old "avg_response_time" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldAvgResponseTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgResponseTime: %w", err)
	}
	return oldValue.AvgResponseTime, nil
}

// AddAvgResponseTime adds f to the "avg_response_time" field.
func (m *ApiStatisticsMutation) AddAvgResponseTime(f float64) {
	if m.addavg_response_time != nil {
		*m.addavg_response_time += f
	} else {
		m.addavg_response_time = &f
	}
}

// AddedAvgResponseTime returns the value that was added to the "avg_response_time" field in this mutation.
func (m *ApiStatisticsMutation) AddedAvgResponseTime() (r float64, exists bool) {
	v := m.addavg_response_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgResponseTime resets all changes to the "avg_response_time" field.
func (m *ApiStatisticsMutation) ResetAvgResponseTime() {
	m.avg_response_time = nil
	m.addavg_response_time = nil
}

// SetMaxResponseTime sets the "max_response_time" field.
func (m *ApiStatisticsMutation) SetMaxResponseTime(f float64) {
	m.max_response_time = &f
	m.addmax_response_time = nil
}

// MaxResponseTime returns the value of the "max_response_time" field in the mutation.
func (m *ApiStatisticsMutation) MaxResponseTime() (r float64, exists bool) {
	v := m.max_response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxResponseTime returns the old "max_response_time" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldMaxResponseTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxResponseTime: %w", err)
	}
	return oldValue.MaxResponseTime, nil
}

// AddMaxResponseTime adds f to the "max_response_time" field.
func (m *ApiStatisticsMutation) AddMaxResponseTime(f float64) {
	if m.addmax_response_time != nil {
		*m.addmax_response_time += f
	} else {
		m.addmax_response_time = &f
	}
}

// AddedMaxResponseTime returns the value that was added to the "max_response_time" field in this mutation.
func (m *ApiStatisticsMutation) AddedMaxResponseTime() (r float64, exists bool) {
	v := m.addmax_response_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxResponseTime resets all changes to the "max_response_time" field.
func (m *ApiStatisticsMutation) ResetMaxResponseTime() {
	m.max_response_time = nil
	m.addmax_response_time = nil
}

// SetMinResponseTime sets the "min_response_time" field.
func (m *ApiStatisticsMutation) SetMinResponseTime(f float64) {
	m.min_response_time = &f
	m.addmin_response_time = nil
}

// MinResponseTime returns the value of the "min_response_time" field in the mutation.
func (m *ApiStatisticsMutation) MinResponseTime() (r float64, exists bool) {
	v := m.min_response_time
	if v == nil {
		return
	}
	return *v, true
}

// OldMinResponseTime returns the old "min_response_time" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldMinResponseTime(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinResponseTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinResponseTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinResponseTime: %w", err)
	}
	return oldValue.MinResponseTime, nil
}

// AddMinResponseTime adds f to the "min_response_time" field.
func (m *ApiStatisticsMutation) AddMinResponseTime(f float64) {
	if m.addmin_response_time != nil {
		*m.addmin_response_time += f
	} else {
		m.addmin_response_time = &f
	}
}

// AddedMinResponseTime returns the value that was added to the "min_response_time" field in this mutation.
func (m *ApiStatisticsMutation) AddedMinResponseTime() (r float64, exists bool) {
	v := m.addmin_response_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinResponseTime resets all changes to the "min_response_time" field.
func (m *ApiStatisticsMutation) ResetMinResponseTime() {
	m.min_response_time = nil
	m.addmin_response_time = nil
}

// SetAvgTraffic sets the "avg_traffic" field.
func (m *ApiStatisticsMutation) SetAvgTraffic(f float64) {
	m.avg_traffic = &f
	m.addavg_traffic = nil
}

// AvgTraffic returns the value of the "avg_traffic" field in the mutation.
func (m *ApiStatisticsMutation) AvgTraffic() (r float64, exists bool) {
	v := m.avg_traffic
	if v == nil {
		return
	}
	return *v, true
}

// OldAvgTraffic returns the old "avg_traffic" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldAvgTraffic(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvgTraffic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvgTraffic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvgTraffic: %w", err)
	}
	return oldValue.AvgTraffic, nil
}

// AddAvgTraffic adds f to the "avg_traffic" field.
func (m *ApiStatisticsMutation) AddAvgTraffic(f float64) {
	if m.addavg_traffic != nil {
		*m.addavg_traffic += f
	} else {
		m.addavg_traffic = &f
	}
}

// AddedAvgTraffic returns the value that was added to the "avg_traffic" field in this mutation.
func (m *ApiStatisticsMutation) AddedAvgTraffic() (r float64, exists bool) {
	v := m.addavg_traffic
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvgTraffic resets all changes to the "avg_traffic" field.
func (m *ApiStatisticsMutation) ResetAvgTraffic() {
	m.avg_traffic = nil
	m.addavg_traffic = nil
}

// SetMaxTraffic sets the "max_traffic" field.
func (m *ApiStatisticsMutation) SetMaxTraffic(f float64) {
	m.max_traffic = &f
	m.addmax_traffic = nil
}

// MaxTraffic returns the value of the "max_traffic" field in the mutation.
func (m *ApiStatisticsMutation) MaxTraffic() (r float64, exists bool) {
	v := m.max_traffic
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTraffic returns the old "max_traffic" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldMaxTraffic(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTraffic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTraffic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTraffic: %w", err)
	}
	return oldValue.MaxTraffic, nil
}

// AddMaxTraffic adds f to the "max_traffic" field.
func (m *ApiStatisticsMutation) AddMaxTraffic(f float64) {
	if m.addmax_traffic != nil {
		*m.addmax_traffic += f
	} else {
		m.addmax_traffic = &f
	}
}

// AddedMaxTraffic returns the value that was added to the "max_traffic" field in this mutation.
func (m *ApiStatisticsMutation) AddedMaxTraffic() (r float64, exists bool) {
	v := m.addmax_traffic
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxTraffic resets all changes to the "max_traffic" field.
func (m *ApiStatisticsMutation) ResetMaxTraffic() {
	m.max_traffic = nil
	m.addmax_traffic = nil
}

// SetMinTraffic sets the "min_traffic" field.
func (m *ApiStatisticsMutation) SetMinTraffic(f float64) {
	m.min_traffic = &f
	m.addmin_traffic = nil
}

// MinTraffic returns the value of the "min_traffic" field in the mutation.
func (m *ApiStatisticsMutation) MinTraffic() (r float64, exists bool) {
	v := m.min_traffic
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTraffic returns the old "min_traffic" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldMinTraffic(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTraffic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTraffic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTraffic: %w", err)
	}
	return oldValue.MinTraffic, nil
}

// AddMinTraffic adds f to the "min_traffic" field.
func (m *ApiStatisticsMutation) AddMinTraffic(f float64) {
	if m.addmin_traffic != nil {
		*m.addmin_traffic += f
	} else {
		m.addmin_traffic = &f
	}
}

// AddedMinTraffic returns the value that was added to the "min_traffic" field in this mutation.
func (m *ApiStatisticsMutation) AddedMinTraffic() (r float64, exists bool) {
	v := m.addmin_traffic
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinTraffic resets all changes to the "min_traffic" field.
func (m *ApiStatisticsMutation) ResetMinTraffic() {
	m.min_traffic = nil
	m.addmin_traffic = nil
}

// SetDescription sets the "description" field.
func (m *ApiStatisticsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApiStatisticsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ApiStatisticsMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiStatisticsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiStatisticsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiStatisticsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ApiStatisticsMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ApiStatisticsMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ApiStatisticsMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetAPIID sets the "api_id" field.
func (m *ApiStatisticsMutation) SetAPIID(i int32) {
	m.api_id = &i
	m.addapi_id = nil
}

// APIID returns the value of the "api_id" field in the mutation.
func (m *ApiStatisticsMutation) APIID() (r int32, exists bool) {
	v := m.api_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIID returns the old "api_id" field's value of the ApiStatistics entity.
// If the ApiStatistics object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiStatisticsMutation) OldAPIID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIID: %w", err)
	}
	return oldValue.APIID, nil
}

// AddAPIID adds i to the "api_id" field.
func (m *ApiStatisticsMutation) AddAPIID(i int32) {
	if m.addapi_id != nil {
		*m.addapi_id += i
	} else {
		m.addapi_id = &i
	}
}

// AddedAPIID returns the value that was added to the "api_id" field in this mutation.
func (m *ApiStatisticsMutation) AddedAPIID() (r int32, exists bool) {
	v := m.addapi_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAPIID resets all changes to the "api_id" field.
func (m *ApiStatisticsMutation) ResetAPIID() {
	m.api_id = nil
	m.addapi_id = nil
}

// Where appends a list predicates to the ApiStatisticsMutation builder.
func (m *ApiStatisticsMutation) Where(ps ...predicate.ApiStatistics) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiStatisticsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiStatisticsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiStatistics, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiStatisticsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiStatisticsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiStatistics).
func (m *ApiStatisticsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiStatisticsMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.call_count != nil {
		fields = append(fields, apistatistics.FieldCallCount)
	}
	if m.success_count != nil {
		fields = append(fields, apistatistics.FieldSuccessCount)
	}
	if m.failure_count != nil {
		fields = append(fields, apistatistics.FieldFailureCount)
	}
	if m.avg_response_time != nil {
		fields = append(fields, apistatistics.FieldAvgResponseTime)
	}
	if m.max_response_time != nil {
		fields = append(fields, apistatistics.FieldMaxResponseTime)
	}
	if m.min_response_time != nil {
		fields = append(fields, apistatistics.FieldMinResponseTime)
	}
	if m.avg_traffic != nil {
		fields = append(fields, apistatistics.FieldAvgTraffic)
	}
	if m.max_traffic != nil {
		fields = append(fields, apistatistics.FieldMaxTraffic)
	}
	if m.min_traffic != nil {
		fields = append(fields, apistatistics.FieldMinTraffic)
	}
	if m.description != nil {
		fields = append(fields, apistatistics.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, apistatistics.FieldCreatedAt)
	}
	if m.update_at != nil {
		fields = append(fields, apistatistics.FieldUpdateAt)
	}
	if m.api_id != nil {
		fields = append(fields, apistatistics.FieldAPIID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiStatisticsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apistatistics.FieldCallCount:
		return m.CallCount()
	case apistatistics.FieldSuccessCount:
		return m.SuccessCount()
	case apistatistics.FieldFailureCount:
		return m.FailureCount()
	case apistatistics.FieldAvgResponseTime:
		return m.AvgResponseTime()
	case apistatistics.FieldMaxResponseTime:
		return m.MaxResponseTime()
	case apistatistics.FieldMinResponseTime:
		return m.MinResponseTime()
	case apistatistics.FieldAvgTraffic:
		return m.AvgTraffic()
	case apistatistics.FieldMaxTraffic:
		return m.MaxTraffic()
	case apistatistics.FieldMinTraffic:
		return m.MinTraffic()
	case apistatistics.FieldDescription:
		return m.Description()
	case apistatistics.FieldCreatedAt:
		return m.CreatedAt()
	case apistatistics.FieldUpdateAt:
		return m.UpdateAt()
	case apistatistics.FieldAPIID:
		return m.APIID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiStatisticsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apistatistics.FieldCallCount:
		return m.OldCallCount(ctx)
	case apistatistics.FieldSuccessCount:
		return m.OldSuccessCount(ctx)
	case apistatistics.FieldFailureCount:
		return m.OldFailureCount(ctx)
	case apistatistics.FieldAvgResponseTime:
		return m.OldAvgResponseTime(ctx)
	case apistatistics.FieldMaxResponseTime:
		return m.OldMaxResponseTime(ctx)
	case apistatistics.FieldMinResponseTime:
		return m.OldMinResponseTime(ctx)
	case apistatistics.FieldAvgTraffic:
		return m.OldAvgTraffic(ctx)
	case apistatistics.FieldMaxTraffic:
		return m.OldMaxTraffic(ctx)
	case apistatistics.FieldMinTraffic:
		return m.OldMinTraffic(ctx)
	case apistatistics.FieldDescription:
		return m.OldDescription(ctx)
	case apistatistics.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apistatistics.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case apistatistics.FieldAPIID:
		return m.OldAPIID(ctx)
	}
	return nil, fmt.Errorf("unknown ApiStatistics field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiStatisticsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apistatistics.FieldCallCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallCount(v)
		return nil
	case apistatistics.FieldSuccessCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessCount(v)
		return nil
	case apistatistics.FieldFailureCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureCount(v)
		return nil
	case apistatistics.FieldAvgResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgResponseTime(v)
		return nil
	case apistatistics.FieldMaxResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxResponseTime(v)
		return nil
	case apistatistics.FieldMinResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinResponseTime(v)
		return nil
	case apistatistics.FieldAvgTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvgTraffic(v)
		return nil
	case apistatistics.FieldMaxTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTraffic(v)
		return nil
	case apistatistics.FieldMinTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTraffic(v)
		return nil
	case apistatistics.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case apistatistics.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apistatistics.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case apistatistics.FieldAPIID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIID(v)
		return nil
	}
	return fmt.Errorf("unknown ApiStatistics field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiStatisticsMutation) AddedFields() []string {
	var fields []string
	if m.addcall_count != nil {
		fields = append(fields, apistatistics.FieldCallCount)
	}
	if m.addsuccess_count != nil {
		fields = append(fields, apistatistics.FieldSuccessCount)
	}
	if m.addfailure_count != nil {
		fields = append(fields, apistatistics.FieldFailureCount)
	}
	if m.addavg_response_time != nil {
		fields = append(fields, apistatistics.FieldAvgResponseTime)
	}
	if m.addmax_response_time != nil {
		fields = append(fields, apistatistics.FieldMaxResponseTime)
	}
	if m.addmin_response_time != nil {
		fields = append(fields, apistatistics.FieldMinResponseTime)
	}
	if m.addavg_traffic != nil {
		fields = append(fields, apistatistics.FieldAvgTraffic)
	}
	if m.addmax_traffic != nil {
		fields = append(fields, apistatistics.FieldMaxTraffic)
	}
	if m.addmin_traffic != nil {
		fields = append(fields, apistatistics.FieldMinTraffic)
	}
	if m.addapi_id != nil {
		fields = append(fields, apistatistics.FieldAPIID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiStatisticsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apistatistics.FieldCallCount:
		return m.AddedCallCount()
	case apistatistics.FieldSuccessCount:
		return m.AddedSuccessCount()
	case apistatistics.FieldFailureCount:
		return m.AddedFailureCount()
	case apistatistics.FieldAvgResponseTime:
		return m.AddedAvgResponseTime()
	case apistatistics.FieldMaxResponseTime:
		return m.AddedMaxResponseTime()
	case apistatistics.FieldMinResponseTime:
		return m.AddedMinResponseTime()
	case apistatistics.FieldAvgTraffic:
		return m.AddedAvgTraffic()
	case apistatistics.FieldMaxTraffic:
		return m.AddedMaxTraffic()
	case apistatistics.FieldMinTraffic:
		return m.AddedMinTraffic()
	case apistatistics.FieldAPIID:
		return m.AddedAPIID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiStatisticsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apistatistics.FieldCallCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCallCount(v)
		return nil
	case apistatistics.FieldSuccessCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuccessCount(v)
		return nil
	case apistatistics.FieldFailureCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFailureCount(v)
		return nil
	case apistatistics.FieldAvgResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgResponseTime(v)
		return nil
	case apistatistics.FieldMaxResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxResponseTime(v)
		return nil
	case apistatistics.FieldMinResponseTime:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinResponseTime(v)
		return nil
	case apistatistics.FieldAvgTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvgTraffic(v)
		return nil
	case apistatistics.FieldMaxTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTraffic(v)
		return nil
	case apistatistics.FieldMinTraffic:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTraffic(v)
		return nil
	case apistatistics.FieldAPIID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAPIID(v)
		return nil
	}
	return fmt.Errorf("unknown ApiStatistics numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiStatisticsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiStatisticsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiStatisticsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiStatistics nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiStatisticsMutation) ResetField(name string) error {
	switch name {
	case apistatistics.FieldCallCount:
		m.ResetCallCount()
		return nil
	case apistatistics.FieldSuccessCount:
		m.ResetSuccessCount()
		return nil
	case apistatistics.FieldFailureCount:
		m.ResetFailureCount()
		return nil
	case apistatistics.FieldAvgResponseTime:
		m.ResetAvgResponseTime()
		return nil
	case apistatistics.FieldMaxResponseTime:
		m.ResetMaxResponseTime()
		return nil
	case apistatistics.FieldMinResponseTime:
		m.ResetMinResponseTime()
		return nil
	case apistatistics.FieldAvgTraffic:
		m.ResetAvgTraffic()
		return nil
	case apistatistics.FieldMaxTraffic:
		m.ResetMaxTraffic()
		return nil
	case apistatistics.FieldMinTraffic:
		m.ResetMinTraffic()
		return nil
	case apistatistics.FieldDescription:
		m.ResetDescription()
		return nil
	case apistatistics.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apistatistics.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case apistatistics.FieldAPIID:
		m.ResetAPIID()
		return nil
	}
	return fmt.Errorf("unknown ApiStatistics field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiStatisticsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiStatisticsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiStatisticsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiStatisticsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiStatisticsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiStatisticsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiStatisticsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiStatistics unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiStatisticsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiStatistics edge %s", name)
}

// ApiTagMutation represents an operation that mutates the ApiTag nodes in the graph.
type ApiTagMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	name          *string
	sort          *int32
	addsort       *int32
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	update_at     *time.Time
	update_by     *uint32
	addupdate_by  *int32
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiTag, error)
	predicates    []predicate.ApiTag
}

var _ ent.Mutation = (*ApiTagMutation)(nil)

// apitagOption allows management of the mutation configuration using functional options.
type apitagOption func(*ApiTagMutation)

// newApiTagMutation creates new mutation for the ApiTag entity.
func newApiTagMutation(c config, op Op, opts ...apitagOption) *ApiTagMutation {
	m := &ApiTagMutation{
		config:        c,
		op:            op,
		typ:           TypeApiTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiTagID sets the ID field of the mutation.
func withApiTagID(id int32) apitagOption {
	return func(m *ApiTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiTag
		)
		m.oldValue = func(ctx context.Context) (*ApiTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiTag sets the old ApiTag of the mutation.
func withApiTag(node *ApiTag) apitagOption {
	return func(m *ApiTagMutation) {
		m.oldValue = func(context.Context) (*ApiTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiTag entities.
func (m *ApiTagMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiTagMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiTagMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ApiTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApiTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApiTagMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *ApiTagMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ApiTagMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ApiTagMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ApiTagMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ApiTagMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ApiTagMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ApiTagMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *ApiTagMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ApiTagMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ApiTagMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *ApiTagMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *ApiTagMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *ApiTagMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *ApiTagMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *ApiTagMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldUpdateBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *ApiTagMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *ApiTagMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *ApiTagMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetDescription sets the "description" field.
func (m *ApiTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ApiTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ApiTag entity.
// If the ApiTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ApiTagMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the ApiTagMutation builder.
func (m *ApiTagMutation) Where(ps ...predicate.ApiTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiTag).
func (m *ApiTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiTagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, apitag.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, apitag.FieldSort)
	}
	if m.created_at != nil {
		fields = append(fields, apitag.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, apitag.FieldCreatedBy)
	}
	if m.update_at != nil {
		fields = append(fields, apitag.FieldUpdateAt)
	}
	if m.update_by != nil {
		fields = append(fields, apitag.FieldUpdateBy)
	}
	if m.description != nil {
		fields = append(fields, apitag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitag.FieldName:
		return m.Name()
	case apitag.FieldSort:
		return m.Sort()
	case apitag.FieldCreatedAt:
		return m.CreatedAt()
	case apitag.FieldCreatedBy:
		return m.CreatedBy()
	case apitag.FieldUpdateAt:
		return m.UpdateAt()
	case apitag.FieldUpdateBy:
		return m.UpdateBy()
	case apitag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitag.FieldName:
		return m.OldName(ctx)
	case apitag.FieldSort:
		return m.OldSort(ctx)
	case apitag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitag.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case apitag.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case apitag.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case apitag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ApiTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitag.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case apitag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitag.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case apitag.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case apitag.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case apitag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ApiTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiTagMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, apitag.FieldSort)
	}
	if m.addcreated_by != nil {
		fields = append(fields, apitag.FieldCreatedBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, apitag.FieldUpdateBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apitag.FieldSort:
		return m.AddedSort()
	case apitag.FieldCreatedBy:
		return m.AddedCreatedBy()
	case apitag.FieldUpdateBy:
		return m.AddedUpdateBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apitag.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case apitag.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case apitag.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	}
	return fmt.Errorf("unknown ApiTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiTagMutation) ResetField(name string) error {
	switch name {
	case apitag.FieldName:
		m.ResetName()
		return nil
	case apitag.FieldSort:
		m.ResetSort()
		return nil
	case apitag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitag.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case apitag.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case apitag.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case apitag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ApiTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiTagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiTagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiTagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiTagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiTag edge %s", name)
}

// ContainerMutation represents an operation that mutates the Container nodes in the graph.
type ContainerMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	hostname           *string
	domainname         *string
	user               *string
	env                *[]string
	appendenv          []string
	cmd                *[]string
	appendcmd          []string
	image              *string
	labels             *[]string
	appendlabels       []string
	volumes            *[]string
	appendvolumes      []string
	working_dir        *string
	entrypoint         *[]string
	appendentrypoint   []string
	mac_address        *string
	expose_ports       *[]string
	appendexpose_ports []string
	compose_file_url   *string
	dockerfile_url     *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Container, error)
	predicates         []predicate.Container
}

var _ ent.Mutation = (*ContainerMutation)(nil)

// containerOption allows management of the mutation configuration using functional options.
type containerOption func(*ContainerMutation)

// newContainerMutation creates new mutation for the Container entity.
func newContainerMutation(c config, op Op, opts ...containerOption) *ContainerMutation {
	m := &ContainerMutation{
		config:        c,
		op:            op,
		typ:           TypeContainer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContainerID sets the ID field of the mutation.
func withContainerID(id string) containerOption {
	return func(m *ContainerMutation) {
		var (
			err   error
			once  sync.Once
			value *Container
		)
		m.oldValue = func(ctx context.Context) (*Container, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Container.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContainer sets the old Container of the mutation.
func withContainer(node *Container) containerOption {
	return func(m *ContainerMutation) {
		m.oldValue = func(context.Context) (*Container, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContainerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContainerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Container entities.
func (m *ContainerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContainerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContainerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Container.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostname sets the "hostname" field.
func (m *ContainerMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *ContainerMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *ContainerMutation) ResetHostname() {
	m.hostname = nil
}

// SetDomainname sets the "domainname" field.
func (m *ContainerMutation) SetDomainname(s string) {
	m.domainname = &s
}

// Domainname returns the value of the "domainname" field in the mutation.
func (m *ContainerMutation) Domainname() (r string, exists bool) {
	v := m.domainname
	if v == nil {
		return
	}
	return *v, true
}

// OldDomainname returns the old "domainname" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldDomainname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomainname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomainname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomainname: %w", err)
	}
	return oldValue.Domainname, nil
}

// ResetDomainname resets all changes to the "domainname" field.
func (m *ContainerMutation) ResetDomainname() {
	m.domainname = nil
}

// SetUser sets the "user" field.
func (m *ContainerMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *ContainerMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ClearUser clears the value of the "user" field.
func (m *ContainerMutation) ClearUser() {
	m.user = nil
	m.clearedFields[container.FieldUser] = struct{}{}
}

// UserCleared returns if the "user" field was cleared in this mutation.
func (m *ContainerMutation) UserCleared() bool {
	_, ok := m.clearedFields[container.FieldUser]
	return ok
}

// ResetUser resets all changes to the "user" field.
func (m *ContainerMutation) ResetUser() {
	m.user = nil
	delete(m.clearedFields, container.FieldUser)
}

// SetEnv sets the "env" field.
func (m *ContainerMutation) SetEnv(s []string) {
	m.env = &s
	m.appendenv = nil
}

// Env returns the value of the "env" field in the mutation.
func (m *ContainerMutation) Env() (r []string, exists bool) {
	v := m.env
	if v == nil {
		return
	}
	return *v, true
}

// OldEnv returns the old "env" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldEnv(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnv: %w", err)
	}
	return oldValue.Env, nil
}

// AppendEnv adds s to the "env" field.
func (m *ContainerMutation) AppendEnv(s []string) {
	m.appendenv = append(m.appendenv, s...)
}

// AppendedEnv returns the list of values that were appended to the "env" field in this mutation.
func (m *ContainerMutation) AppendedEnv() ([]string, bool) {
	if len(m.appendenv) == 0 {
		return nil, false
	}
	return m.appendenv, true
}

// ClearEnv clears the value of the "env" field.
func (m *ContainerMutation) ClearEnv() {
	m.env = nil
	m.appendenv = nil
	m.clearedFields[container.FieldEnv] = struct{}{}
}

// EnvCleared returns if the "env" field was cleared in this mutation.
func (m *ContainerMutation) EnvCleared() bool {
	_, ok := m.clearedFields[container.FieldEnv]
	return ok
}

// ResetEnv resets all changes to the "env" field.
func (m *ContainerMutation) ResetEnv() {
	m.env = nil
	m.appendenv = nil
	delete(m.clearedFields, container.FieldEnv)
}

// SetCmd sets the "cmd" field.
func (m *ContainerMutation) SetCmd(s []string) {
	m.cmd = &s
	m.appendcmd = nil
}

// Cmd returns the value of the "cmd" field in the mutation.
func (m *ContainerMutation) Cmd() (r []string, exists bool) {
	v := m.cmd
	if v == nil {
		return
	}
	return *v, true
}

// OldCmd returns the old "cmd" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldCmd(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCmd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCmd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCmd: %w", err)
	}
	return oldValue.Cmd, nil
}

// AppendCmd adds s to the "cmd" field.
func (m *ContainerMutation) AppendCmd(s []string) {
	m.appendcmd = append(m.appendcmd, s...)
}

// AppendedCmd returns the list of values that were appended to the "cmd" field in this mutation.
func (m *ContainerMutation) AppendedCmd() ([]string, bool) {
	if len(m.appendcmd) == 0 {
		return nil, false
	}
	return m.appendcmd, true
}

// ClearCmd clears the value of the "cmd" field.
func (m *ContainerMutation) ClearCmd() {
	m.cmd = nil
	m.appendcmd = nil
	m.clearedFields[container.FieldCmd] = struct{}{}
}

// CmdCleared returns if the "cmd" field was cleared in this mutation.
func (m *ContainerMutation) CmdCleared() bool {
	_, ok := m.clearedFields[container.FieldCmd]
	return ok
}

// ResetCmd resets all changes to the "cmd" field.
func (m *ContainerMutation) ResetCmd() {
	m.cmd = nil
	m.appendcmd = nil
	delete(m.clearedFields, container.FieldCmd)
}

// SetImage sets the "image" field.
func (m *ContainerMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ContainerMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ContainerMutation) ResetImage() {
	m.image = nil
}

// SetLabels sets the "labels" field.
func (m *ContainerMutation) SetLabels(s []string) {
	m.labels = &s
	m.appendlabels = nil
}

// Labels returns the value of the "labels" field in the mutation.
func (m *ContainerMutation) Labels() (r []string, exists bool) {
	v := m.labels
	if v == nil {
		return
	}
	return *v, true
}

// OldLabels returns the old "labels" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldLabels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabels: %w", err)
	}
	return oldValue.Labels, nil
}

// AppendLabels adds s to the "labels" field.
func (m *ContainerMutation) AppendLabels(s []string) {
	m.appendlabels = append(m.appendlabels, s...)
}

// AppendedLabels returns the list of values that were appended to the "labels" field in this mutation.
func (m *ContainerMutation) AppendedLabels() ([]string, bool) {
	if len(m.appendlabels) == 0 {
		return nil, false
	}
	return m.appendlabels, true
}

// ClearLabels clears the value of the "labels" field.
func (m *ContainerMutation) ClearLabels() {
	m.labels = nil
	m.appendlabels = nil
	m.clearedFields[container.FieldLabels] = struct{}{}
}

// LabelsCleared returns if the "labels" field was cleared in this mutation.
func (m *ContainerMutation) LabelsCleared() bool {
	_, ok := m.clearedFields[container.FieldLabels]
	return ok
}

// ResetLabels resets all changes to the "labels" field.
func (m *ContainerMutation) ResetLabels() {
	m.labels = nil
	m.appendlabels = nil
	delete(m.clearedFields, container.FieldLabels)
}

// SetVolumes sets the "volumes" field.
func (m *ContainerMutation) SetVolumes(s []string) {
	m.volumes = &s
	m.appendvolumes = nil
}

// Volumes returns the value of the "volumes" field in the mutation.
func (m *ContainerMutation) Volumes() (r []string, exists bool) {
	v := m.volumes
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumes returns the old "volumes" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldVolumes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumes: %w", err)
	}
	return oldValue.Volumes, nil
}

// AppendVolumes adds s to the "volumes" field.
func (m *ContainerMutation) AppendVolumes(s []string) {
	m.appendvolumes = append(m.appendvolumes, s...)
}

// AppendedVolumes returns the list of values that were appended to the "volumes" field in this mutation.
func (m *ContainerMutation) AppendedVolumes() ([]string, bool) {
	if len(m.appendvolumes) == 0 {
		return nil, false
	}
	return m.appendvolumes, true
}

// ClearVolumes clears the value of the "volumes" field.
func (m *ContainerMutation) ClearVolumes() {
	m.volumes = nil
	m.appendvolumes = nil
	m.clearedFields[container.FieldVolumes] = struct{}{}
}

// VolumesCleared returns if the "volumes" field was cleared in this mutation.
func (m *ContainerMutation) VolumesCleared() bool {
	_, ok := m.clearedFields[container.FieldVolumes]
	return ok
}

// ResetVolumes resets all changes to the "volumes" field.
func (m *ContainerMutation) ResetVolumes() {
	m.volumes = nil
	m.appendvolumes = nil
	delete(m.clearedFields, container.FieldVolumes)
}

// SetWorkingDir sets the "working_dir" field.
func (m *ContainerMutation) SetWorkingDir(s string) {
	m.working_dir = &s
}

// WorkingDir returns the value of the "working_dir" field in the mutation.
func (m *ContainerMutation) WorkingDir() (r string, exists bool) {
	v := m.working_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkingDir returns the old "working_dir" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldWorkingDir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkingDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkingDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkingDir: %w", err)
	}
	return oldValue.WorkingDir, nil
}

// ClearWorkingDir clears the value of the "working_dir" field.
func (m *ContainerMutation) ClearWorkingDir() {
	m.working_dir = nil
	m.clearedFields[container.FieldWorkingDir] = struct{}{}
}

// WorkingDirCleared returns if the "working_dir" field was cleared in this mutation.
func (m *ContainerMutation) WorkingDirCleared() bool {
	_, ok := m.clearedFields[container.FieldWorkingDir]
	return ok
}

// ResetWorkingDir resets all changes to the "working_dir" field.
func (m *ContainerMutation) ResetWorkingDir() {
	m.working_dir = nil
	delete(m.clearedFields, container.FieldWorkingDir)
}

// SetEntrypoint sets the "entrypoint" field.
func (m *ContainerMutation) SetEntrypoint(s []string) {
	m.entrypoint = &s
	m.appendentrypoint = nil
}

// Entrypoint returns the value of the "entrypoint" field in the mutation.
func (m *ContainerMutation) Entrypoint() (r []string, exists bool) {
	v := m.entrypoint
	if v == nil {
		return
	}
	return *v, true
}

// OldEntrypoint returns the old "entrypoint" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldEntrypoint(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntrypoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntrypoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntrypoint: %w", err)
	}
	return oldValue.Entrypoint, nil
}

// AppendEntrypoint adds s to the "entrypoint" field.
func (m *ContainerMutation) AppendEntrypoint(s []string) {
	m.appendentrypoint = append(m.appendentrypoint, s...)
}

// AppendedEntrypoint returns the list of values that were appended to the "entrypoint" field in this mutation.
func (m *ContainerMutation) AppendedEntrypoint() ([]string, bool) {
	if len(m.appendentrypoint) == 0 {
		return nil, false
	}
	return m.appendentrypoint, true
}

// ClearEntrypoint clears the value of the "entrypoint" field.
func (m *ContainerMutation) ClearEntrypoint() {
	m.entrypoint = nil
	m.appendentrypoint = nil
	m.clearedFields[container.FieldEntrypoint] = struct{}{}
}

// EntrypointCleared returns if the "entrypoint" field was cleared in this mutation.
func (m *ContainerMutation) EntrypointCleared() bool {
	_, ok := m.clearedFields[container.FieldEntrypoint]
	return ok
}

// ResetEntrypoint resets all changes to the "entrypoint" field.
func (m *ContainerMutation) ResetEntrypoint() {
	m.entrypoint = nil
	m.appendentrypoint = nil
	delete(m.clearedFields, container.FieldEntrypoint)
}

// SetMACAddress sets the "mac_address" field.
func (m *ContainerMutation) SetMACAddress(s string) {
	m.mac_address = &s
}

// MACAddress returns the value of the "mac_address" field in the mutation.
func (m *ContainerMutation) MACAddress() (r string, exists bool) {
	v := m.mac_address
	if v == nil {
		return
	}
	return *v, true
}

// OldMACAddress returns the old "mac_address" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldMACAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMACAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMACAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMACAddress: %w", err)
	}
	return oldValue.MACAddress, nil
}

// ResetMACAddress resets all changes to the "mac_address" field.
func (m *ContainerMutation) ResetMACAddress() {
	m.mac_address = nil
}

// SetExposePorts sets the "expose_ports" field.
func (m *ContainerMutation) SetExposePorts(s []string) {
	m.expose_ports = &s
	m.appendexpose_ports = nil
}

// ExposePorts returns the value of the "expose_ports" field in the mutation.
func (m *ContainerMutation) ExposePorts() (r []string, exists bool) {
	v := m.expose_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposePorts returns the old "expose_ports" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldExposePorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposePorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposePorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposePorts: %w", err)
	}
	return oldValue.ExposePorts, nil
}

// AppendExposePorts adds s to the "expose_ports" field.
func (m *ContainerMutation) AppendExposePorts(s []string) {
	m.appendexpose_ports = append(m.appendexpose_ports, s...)
}

// AppendedExposePorts returns the list of values that were appended to the "expose_ports" field in this mutation.
func (m *ContainerMutation) AppendedExposePorts() ([]string, bool) {
	if len(m.appendexpose_ports) == 0 {
		return nil, false
	}
	return m.appendexpose_ports, true
}

// ClearExposePorts clears the value of the "expose_ports" field.
func (m *ContainerMutation) ClearExposePorts() {
	m.expose_ports = nil
	m.appendexpose_ports = nil
	m.clearedFields[container.FieldExposePorts] = struct{}{}
}

// ExposePortsCleared returns if the "expose_ports" field was cleared in this mutation.
func (m *ContainerMutation) ExposePortsCleared() bool {
	_, ok := m.clearedFields[container.FieldExposePorts]
	return ok
}

// ResetExposePorts resets all changes to the "expose_ports" field.
func (m *ContainerMutation) ResetExposePorts() {
	m.expose_ports = nil
	m.appendexpose_ports = nil
	delete(m.clearedFields, container.FieldExposePorts)
}

// SetComposeFileURL sets the "compose_file_url" field.
func (m *ContainerMutation) SetComposeFileURL(s string) {
	m.compose_file_url = &s
}

// ComposeFileURL returns the value of the "compose_file_url" field in the mutation.
func (m *ContainerMutation) ComposeFileURL() (r string, exists bool) {
	v := m.compose_file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldComposeFileURL returns the old "compose_file_url" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldComposeFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComposeFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComposeFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComposeFileURL: %w", err)
	}
	return oldValue.ComposeFileURL, nil
}

// ClearComposeFileURL clears the value of the "compose_file_url" field.
func (m *ContainerMutation) ClearComposeFileURL() {
	m.compose_file_url = nil
	m.clearedFields[container.FieldComposeFileURL] = struct{}{}
}

// ComposeFileURLCleared returns if the "compose_file_url" field was cleared in this mutation.
func (m *ContainerMutation) ComposeFileURLCleared() bool {
	_, ok := m.clearedFields[container.FieldComposeFileURL]
	return ok
}

// ResetComposeFileURL resets all changes to the "compose_file_url" field.
func (m *ContainerMutation) ResetComposeFileURL() {
	m.compose_file_url = nil
	delete(m.clearedFields, container.FieldComposeFileURL)
}

// SetDockerfileURL sets the "dockerfile_url" field.
func (m *ContainerMutation) SetDockerfileURL(s string) {
	m.dockerfile_url = &s
}

// DockerfileURL returns the value of the "dockerfile_url" field in the mutation.
func (m *ContainerMutation) DockerfileURL() (r string, exists bool) {
	v := m.dockerfile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerfileURL returns the old "dockerfile_url" field's value of the Container entity.
// If the Container object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContainerMutation) OldDockerfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerfileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerfileURL: %w", err)
	}
	return oldValue.DockerfileURL, nil
}

// ClearDockerfileURL clears the value of the "dockerfile_url" field.
func (m *ContainerMutation) ClearDockerfileURL() {
	m.dockerfile_url = nil
	m.clearedFields[container.FieldDockerfileURL] = struct{}{}
}

// DockerfileURLCleared returns if the "dockerfile_url" field was cleared in this mutation.
func (m *ContainerMutation) DockerfileURLCleared() bool {
	_, ok := m.clearedFields[container.FieldDockerfileURL]
	return ok
}

// ResetDockerfileURL resets all changes to the "dockerfile_url" field.
func (m *ContainerMutation) ResetDockerfileURL() {
	m.dockerfile_url = nil
	delete(m.clearedFields, container.FieldDockerfileURL)
}

// Where appends a list predicates to the ContainerMutation builder.
func (m *ContainerMutation) Where(ps ...predicate.Container) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContainerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContainerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Container, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContainerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContainerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Container).
func (m *ContainerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContainerMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hostname != nil {
		fields = append(fields, container.FieldHostname)
	}
	if m.domainname != nil {
		fields = append(fields, container.FieldDomainname)
	}
	if m.user != nil {
		fields = append(fields, container.FieldUser)
	}
	if m.env != nil {
		fields = append(fields, container.FieldEnv)
	}
	if m.cmd != nil {
		fields = append(fields, container.FieldCmd)
	}
	if m.image != nil {
		fields = append(fields, container.FieldImage)
	}
	if m.labels != nil {
		fields = append(fields, container.FieldLabels)
	}
	if m.volumes != nil {
		fields = append(fields, container.FieldVolumes)
	}
	if m.working_dir != nil {
		fields = append(fields, container.FieldWorkingDir)
	}
	if m.entrypoint != nil {
		fields = append(fields, container.FieldEntrypoint)
	}
	if m.mac_address != nil {
		fields = append(fields, container.FieldMACAddress)
	}
	if m.expose_ports != nil {
		fields = append(fields, container.FieldExposePorts)
	}
	if m.compose_file_url != nil {
		fields = append(fields, container.FieldComposeFileURL)
	}
	if m.dockerfile_url != nil {
		fields = append(fields, container.FieldDockerfileURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContainerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case container.FieldHostname:
		return m.Hostname()
	case container.FieldDomainname:
		return m.Domainname()
	case container.FieldUser:
		return m.User()
	case container.FieldEnv:
		return m.Env()
	case container.FieldCmd:
		return m.Cmd()
	case container.FieldImage:
		return m.Image()
	case container.FieldLabels:
		return m.Labels()
	case container.FieldVolumes:
		return m.Volumes()
	case container.FieldWorkingDir:
		return m.WorkingDir()
	case container.FieldEntrypoint:
		return m.Entrypoint()
	case container.FieldMACAddress:
		return m.MACAddress()
	case container.FieldExposePorts:
		return m.ExposePorts()
	case container.FieldComposeFileURL:
		return m.ComposeFileURL()
	case container.FieldDockerfileURL:
		return m.DockerfileURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContainerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case container.FieldHostname:
		return m.OldHostname(ctx)
	case container.FieldDomainname:
		return m.OldDomainname(ctx)
	case container.FieldUser:
		return m.OldUser(ctx)
	case container.FieldEnv:
		return m.OldEnv(ctx)
	case container.FieldCmd:
		return m.OldCmd(ctx)
	case container.FieldImage:
		return m.OldImage(ctx)
	case container.FieldLabels:
		return m.OldLabels(ctx)
	case container.FieldVolumes:
		return m.OldVolumes(ctx)
	case container.FieldWorkingDir:
		return m.OldWorkingDir(ctx)
	case container.FieldEntrypoint:
		return m.OldEntrypoint(ctx)
	case container.FieldMACAddress:
		return m.OldMACAddress(ctx)
	case container.FieldExposePorts:
		return m.OldExposePorts(ctx)
	case container.FieldComposeFileURL:
		return m.OldComposeFileURL(ctx)
	case container.FieldDockerfileURL:
		return m.OldDockerfileURL(ctx)
	}
	return nil, fmt.Errorf("unknown Container field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContainerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case container.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case container.FieldDomainname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainname(v)
		return nil
	case container.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case container.FieldEnv:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnv(v)
		return nil
	case container.FieldCmd:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCmd(v)
		return nil
	case container.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case container.FieldLabels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabels(v)
		return nil
	case container.FieldVolumes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumes(v)
		return nil
	case container.FieldWorkingDir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkingDir(v)
		return nil
	case container.FieldEntrypoint:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntrypoint(v)
		return nil
	case container.FieldMACAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMACAddress(v)
		return nil
	case container.FieldExposePorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposePorts(v)
		return nil
	case container.FieldComposeFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComposeFileURL(v)
		return nil
	case container.FieldDockerfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerfileURL(v)
		return nil
	}
	return fmt.Errorf("unknown Container field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContainerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContainerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContainerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Container numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContainerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(container.FieldUser) {
		fields = append(fields, container.FieldUser)
	}
	if m.FieldCleared(container.FieldEnv) {
		fields = append(fields, container.FieldEnv)
	}
	if m.FieldCleared(container.FieldCmd) {
		fields = append(fields, container.FieldCmd)
	}
	if m.FieldCleared(container.FieldLabels) {
		fields = append(fields, container.FieldLabels)
	}
	if m.FieldCleared(container.FieldVolumes) {
		fields = append(fields, container.FieldVolumes)
	}
	if m.FieldCleared(container.FieldWorkingDir) {
		fields = append(fields, container.FieldWorkingDir)
	}
	if m.FieldCleared(container.FieldEntrypoint) {
		fields = append(fields, container.FieldEntrypoint)
	}
	if m.FieldCleared(container.FieldExposePorts) {
		fields = append(fields, container.FieldExposePorts)
	}
	if m.FieldCleared(container.FieldComposeFileURL) {
		fields = append(fields, container.FieldComposeFileURL)
	}
	if m.FieldCleared(container.FieldDockerfileURL) {
		fields = append(fields, container.FieldDockerfileURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContainerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContainerMutation) ClearField(name string) error {
	switch name {
	case container.FieldUser:
		m.ClearUser()
		return nil
	case container.FieldEnv:
		m.ClearEnv()
		return nil
	case container.FieldCmd:
		m.ClearCmd()
		return nil
	case container.FieldLabels:
		m.ClearLabels()
		return nil
	case container.FieldVolumes:
		m.ClearVolumes()
		return nil
	case container.FieldWorkingDir:
		m.ClearWorkingDir()
		return nil
	case container.FieldEntrypoint:
		m.ClearEntrypoint()
		return nil
	case container.FieldExposePorts:
		m.ClearExposePorts()
		return nil
	case container.FieldComposeFileURL:
		m.ClearComposeFileURL()
		return nil
	case container.FieldDockerfileURL:
		m.ClearDockerfileURL()
		return nil
	}
	return fmt.Errorf("unknown Container nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContainerMutation) ResetField(name string) error {
	switch name {
	case container.FieldHostname:
		m.ResetHostname()
		return nil
	case container.FieldDomainname:
		m.ResetDomainname()
		return nil
	case container.FieldUser:
		m.ResetUser()
		return nil
	case container.FieldEnv:
		m.ResetEnv()
		return nil
	case container.FieldCmd:
		m.ResetCmd()
		return nil
	case container.FieldImage:
		m.ResetImage()
		return nil
	case container.FieldLabels:
		m.ResetLabels()
		return nil
	case container.FieldVolumes:
		m.ResetVolumes()
		return nil
	case container.FieldWorkingDir:
		m.ResetWorkingDir()
		return nil
	case container.FieldEntrypoint:
		m.ResetEntrypoint()
		return nil
	case container.FieldMACAddress:
		m.ResetMACAddress()
		return nil
	case container.FieldExposePorts:
		m.ResetExposePorts()
		return nil
	case container.FieldComposeFileURL:
		m.ResetComposeFileURL()
		return nil
	case container.FieldDockerfileURL:
		m.ResetDockerfileURL()
		return nil
	}
	return fmt.Errorf("unknown Container field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContainerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContainerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContainerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContainerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContainerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContainerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContainerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Container unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContainerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Container edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	avatar        *string
	description   *string
	created_by    *uint32
	addcreated_by *int32
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uint32
	addupdated_by *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	headcount     *int32
	addheadcount  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Group, error)
	predicates    []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Group entities.
func (m *GroupMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetAvatar sets the "avatar" field.
func (m *GroupMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *GroupMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *GroupMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[group.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *GroupMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[group.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *GroupMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, group.FieldAvatar)
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *GroupMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GroupMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *GroupMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[group.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *GroupMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, group.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *GroupMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *GroupMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *GroupMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *GroupMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *GroupMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[group.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *GroupMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[group.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *GroupMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, group.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *GroupMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *GroupMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[group.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, group.FieldDeletedBy)
}

// SetHeadcount sets the "headcount" field.
func (m *GroupMutation) SetHeadcount(i int32) {
	m.headcount = &i
	m.addheadcount = nil
}

// Headcount returns the value of the "headcount" field in the mutation.
func (m *GroupMutation) Headcount() (r int32, exists bool) {
	v := m.headcount
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadcount returns the old "headcount" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldHeadcount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadcount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadcount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadcount: %w", err)
	}
	return oldValue.Headcount, nil
}

// AddHeadcount adds i to the "headcount" field.
func (m *GroupMutation) AddHeadcount(i int32) {
	if m.addheadcount != nil {
		*m.addheadcount += i
	} else {
		m.addheadcount = &i
	}
}

// AddedHeadcount returns the value that was added to the "headcount" field in this mutation.
func (m *GroupMutation) AddedHeadcount() (r int32, exists bool) {
	v := m.addheadcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeadcount resets all changes to the "headcount" field.
func (m *GroupMutation) ResetHeadcount() {
	m.headcount = nil
	m.addheadcount = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.avatar != nil {
		fields = append(fields, group.FieldAvatar)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.created_by != nil {
		fields = append(fields, group.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, group.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, group.FieldDeletedBy)
	}
	if m.headcount != nil {
		fields = append(fields, group.FieldHeadcount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldName:
		return m.Name()
	case group.FieldAvatar:
		return m.Avatar()
	case group.FieldDescription:
		return m.Description()
	case group.FieldCreatedBy:
		return m.CreatedBy()
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldUpdatedBy:
		return m.UpdatedBy()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldDeletedBy:
		return m.DeletedBy()
	case group.FieldHeadcount:
		return m.Headcount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldAvatar:
		return m.OldAvatar(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case group.FieldHeadcount:
		return m.OldHeadcount(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case group.FieldHeadcount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadcount(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, group.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, group.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, group.FieldDeletedBy)
	}
	if m.addheadcount != nil {
		fields = append(fields, group.FieldHeadcount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedBy:
		return m.AddedCreatedBy()
	case group.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case group.FieldDeletedBy:
		return m.AddedDeletedBy()
	case group.FieldHeadcount:
		return m.AddedHeadcount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case group.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case group.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case group.FieldHeadcount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeadcount(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldAvatar) {
		fields = append(fields, group.FieldAvatar)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldUpdatedAt) {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.FieldCleared(group.FieldUpdatedBy) {
		fields = append(fields, group.FieldUpdatedBy)
	}
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldDeletedBy) {
		fields = append(fields, group.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldAvatar:
		m.ClearAvatar()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case group.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldAvatar:
		m.ResetAvatar()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case group.FieldHeadcount:
		m.ResetHeadcount()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupMemberMutation represents an operation that mutates the GroupMember nodes in the graph.
type GroupMemberMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	group_id      *int64
	addgroup_id   *int64
	user_id       *uint32
	adduser_id    *int32
	role          *uint8
	addrole       *int8
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GroupMember, error)
	predicates    []predicate.GroupMember
}

var _ ent.Mutation = (*GroupMemberMutation)(nil)

// groupmemberOption allows management of the mutation configuration using functional options.
type groupmemberOption func(*GroupMemberMutation)

// newGroupMemberMutation creates new mutation for the GroupMember entity.
func newGroupMemberMutation(c config, op Op, opts ...groupmemberOption) *GroupMemberMutation {
	m := &GroupMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMemberID sets the ID field of the mutation.
func withGroupMemberID(id int64) groupmemberOption {
	return func(m *GroupMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMember
		)
		m.oldValue = func(ctx context.Context) (*GroupMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMember sets the old GroupMember of the mutation.
func withGroupMember(node *GroupMember) groupmemberOption {
	return func(m *GroupMemberMutation) {
		m.oldValue = func(context.Context) (*GroupMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GroupMember entities.
func (m *GroupMemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupID sets the "group_id" field.
func (m *GroupMemberMutation) SetGroupID(i int64) {
	m.group_id = &i
	m.addgroup_id = nil
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *GroupMemberMutation) GroupID() (r int64, exists bool) {
	v := m.group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// AddGroupID adds i to the "group_id" field.
func (m *GroupMemberMutation) AddGroupID(i int64) {
	if m.addgroup_id != nil {
		*m.addgroup_id += i
	} else {
		m.addgroup_id = &i
	}
}

// AddedGroupID returns the value that was added to the "group_id" field in this mutation.
func (m *GroupMemberMutation) AddedGroupID() (r int64, exists bool) {
	v := m.addgroup_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *GroupMemberMutation) ResetGroupID() {
	m.group_id = nil
	m.addgroup_id = nil
}

// SetUserID sets the "user_id" field.
func (m *GroupMemberMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GroupMemberMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *GroupMemberMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *GroupMemberMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GroupMemberMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRole sets the "role" field.
func (m *GroupMemberMutation) SetRole(u uint8) {
	m.role = &u
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *GroupMemberMutation) Role() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldRole(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds u to the "role" field.
func (m *GroupMemberMutation) AddRole(u int8) {
	if m.addrole != nil {
		*m.addrole += u
	} else {
		m.addrole = &u
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *GroupMemberMutation) AddedRole() (r int8, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *GroupMemberMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupMemberMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupMemberMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *GroupMemberMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *GroupMemberMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *GroupMemberMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[groupmember.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *GroupMemberMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[groupmember.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupMemberMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, groupmember.FieldCreatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMemberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMemberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMemberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[groupmember.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMemberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[groupmember.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMemberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, groupmember.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *GroupMemberMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *GroupMemberMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *GroupMemberMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *GroupMemberMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *GroupMemberMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[groupmember.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *GroupMemberMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[groupmember.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *GroupMemberMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, groupmember.FieldDeletedBy)
}

// Where appends a list predicates to the GroupMemberMutation builder.
func (m *GroupMemberMutation) Where(ps ...predicate.GroupMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupMember).
func (m *GroupMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMemberMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.group_id != nil {
		fields = append(fields, groupmember.FieldGroupID)
	}
	if m.user_id != nil {
		fields = append(fields, groupmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, groupmember.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, groupmember.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, groupmember.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, groupmember.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, groupmember.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmember.FieldGroupID:
		return m.GroupID()
	case groupmember.FieldUserID:
		return m.UserID()
	case groupmember.FieldRole:
		return m.Role()
	case groupmember.FieldCreatedAt:
		return m.CreatedAt()
	case groupmember.FieldCreatedBy:
		return m.CreatedBy()
	case groupmember.FieldDeletedAt:
		return m.DeletedAt()
	case groupmember.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmember.FieldGroupID:
		return m.OldGroupID(ctx)
	case groupmember.FieldUserID:
		return m.OldUserID(ctx)
	case groupmember.FieldRole:
		return m.OldRole(ctx)
	case groupmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case groupmember.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupmember.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case groupmember.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmember.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case groupmember.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case groupmember.FieldRole:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case groupmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case groupmember.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupmember.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case groupmember.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMemberMutation) AddedFields() []string {
	var fields []string
	if m.addgroup_id != nil {
		fields = append(fields, groupmember.FieldGroupID)
	}
	if m.adduser_id != nil {
		fields = append(fields, groupmember.FieldUserID)
	}
	if m.addrole != nil {
		fields = append(fields, groupmember.FieldRole)
	}
	if m.addcreated_by != nil {
		fields = append(fields, groupmember.FieldCreatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, groupmember.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case groupmember.FieldGroupID:
		return m.AddedGroupID()
	case groupmember.FieldUserID:
		return m.AddedUserID()
	case groupmember.FieldRole:
		return m.AddedRole()
	case groupmember.FieldCreatedBy:
		return m.AddedCreatedBy()
	case groupmember.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case groupmember.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupID(v)
		return nil
	case groupmember.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case groupmember.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	case groupmember.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case groupmember.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmember.FieldCreatedBy) {
		fields = append(fields, groupmember.FieldCreatedBy)
	}
	if m.FieldCleared(groupmember.FieldDeletedAt) {
		fields = append(fields, groupmember.FieldDeletedAt)
	}
	if m.FieldCleared(groupmember.FieldDeletedBy) {
		fields = append(fields, groupmember.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMemberMutation) ClearField(name string) error {
	switch name {
	case groupmember.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case groupmember.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case groupmember.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown GroupMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMemberMutation) ResetField(name string) error {
	switch name {
	case groupmember.FieldGroupID:
		m.ResetGroupID()
		return nil
	case groupmember.FieldUserID:
		m.ResetUserID()
		return nil
	case groupmember.FieldRole:
		m.ResetRole()
		return nil
	case groupmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case groupmember.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupmember.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case groupmember.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown GroupMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMemberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMemberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMemberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMemberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupMember edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	payload       *[]byte
	_type         *string
	updated_at    *time.Time
	worker        *uint32
	addworker     *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	entry_id      *string
	_config       *[]byte
	task_id       *int64
	addtask_id    *int64
	active        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Job, error)
	predicates    []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int64) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *JobMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *JobMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *JobMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *JobMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *JobMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetPayload sets the "payload" field.
func (m *JobMutation) SetPayload(b []byte) {
	m.payload = &b
}

// Payload returns the value of the "payload" field in the mutation.
func (m *JobMutation) Payload() (r []byte, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPayload(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *JobMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[job.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *JobMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[job.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *JobMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, job.FieldPayload)
}

// SetType sets the "type" field.
func (m *JobMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *JobMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *JobMutation) ClearType() {
	m._type = nil
	m.clearedFields[job.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *JobMutation) TypeCleared() bool {
	_, ok := m.clearedFields[job.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *JobMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, job.FieldType)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *JobMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[job.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *JobMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[job.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, job.FieldUpdatedAt)
}

// SetWorker sets the "worker" field.
func (m *JobMutation) SetWorker(u uint32) {
	m.worker = &u
	m.addworker = nil
}

// Worker returns the value of the "worker" field in the mutation.
func (m *JobMutation) Worker() (r uint32, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorker returns the old "worker" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldWorker(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorker: %w", err)
	}
	return oldValue.Worker, nil
}

// AddWorker adds u to the "worker" field.
func (m *JobMutation) AddWorker(u int32) {
	if m.addworker != nil {
		*m.addworker += u
	} else {
		m.addworker = &u
	}
}

// AddedWorker returns the value that was added to the "worker" field in this mutation.
func (m *JobMutation) AddedWorker() (r int32, exists bool) {
	v := m.addworker
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorker resets all changes to the "worker" field.
func (m *JobMutation) ResetWorker() {
	m.worker = nil
	m.addworker = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *JobMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *JobMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *JobMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[job.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *JobMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[job.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *JobMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, job.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *JobMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *JobMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *JobMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *JobMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *JobMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[job.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *JobMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[job.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *JobMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, job.FieldDeletedBy)
}

// SetEntryID sets the "entry_id" field.
func (m *JobMutation) SetEntryID(s string) {
	m.entry_id = &s
}

// EntryID returns the value of the "entry_id" field in the mutation.
func (m *JobMutation) EntryID() (r string, exists bool) {
	v := m.entry_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryID returns the old "entry_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldEntryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryID: %w", err)
	}
	return oldValue.EntryID, nil
}

// ClearEntryID clears the value of the "entry_id" field.
func (m *JobMutation) ClearEntryID() {
	m.entry_id = nil
	m.clearedFields[job.FieldEntryID] = struct{}{}
}

// EntryIDCleared returns if the "entry_id" field was cleared in this mutation.
func (m *JobMutation) EntryIDCleared() bool {
	_, ok := m.clearedFields[job.FieldEntryID]
	return ok
}

// ResetEntryID resets all changes to the "entry_id" field.
func (m *JobMutation) ResetEntryID() {
	m.entry_id = nil
	delete(m.clearedFields, job.FieldEntryID)
}

// SetConfig sets the "config" field.
func (m *JobMutation) SetConfig(b []byte) {
	m._config = &b
}

// Config returns the value of the "config" field in the mutation.
func (m *JobMutation) Config() (r []byte, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldConfig(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *JobMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[job.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *JobMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[job.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *JobMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, job.FieldConfig)
}

// SetTaskID sets the "task_id" field.
func (m *JobMutation) SetTaskID(i int64) {
	m.task_id = &i
	m.addtask_id = nil
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *JobMutation) TaskID() (r int64, exists bool) {
	v := m.task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// AddTaskID adds i to the "task_id" field.
func (m *JobMutation) AddTaskID(i int64) {
	if m.addtask_id != nil {
		*m.addtask_id += i
	} else {
		m.addtask_id = &i
	}
}

// AddedTaskID returns the value that was added to the "task_id" field in this mutation.
func (m *JobMutation) AddedTaskID() (r int64, exists bool) {
	v := m.addtask_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *JobMutation) ResetTaskID() {
	m.task_id = nil
	m.addtask_id = nil
}

// SetActive sets the "active" field.
func (m *JobMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *JobMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *JobMutation) ResetActive() {
	m.active = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, job.FieldCreatedBy)
	}
	if m.payload != nil {
		fields = append(fields, job.FieldPayload)
	}
	if m._type != nil {
		fields = append(fields, job.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	if m.worker != nil {
		fields = append(fields, job.FieldWorker)
	}
	if m.deleted_at != nil {
		fields = append(fields, job.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, job.FieldDeletedBy)
	}
	if m.entry_id != nil {
		fields = append(fields, job.FieldEntryID)
	}
	if m._config != nil {
		fields = append(fields, job.FieldConfig)
	}
	if m.task_id != nil {
		fields = append(fields, job.FieldTaskID)
	}
	if m.active != nil {
		fields = append(fields, job.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldCreatedBy:
		return m.CreatedBy()
	case job.FieldPayload:
		return m.Payload()
	case job.FieldType:
		return m.GetType()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	case job.FieldWorker:
		return m.Worker()
	case job.FieldDeletedAt:
		return m.DeletedAt()
	case job.FieldDeletedBy:
		return m.DeletedBy()
	case job.FieldEntryID:
		return m.EntryID()
	case job.FieldConfig:
		return m.Config()
	case job.FieldTaskID:
		return m.TaskID()
	case job.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case job.FieldPayload:
		return m.OldPayload(ctx)
	case job.FieldType:
		return m.OldType(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case job.FieldWorker:
		return m.OldWorker(ctx)
	case job.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case job.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case job.FieldEntryID:
		return m.OldEntryID(ctx)
	case job.FieldConfig:
		return m.OldConfig(ctx)
	case job.FieldTaskID:
		return m.OldTaskID(ctx)
	case job.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case job.FieldPayload:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case job.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case job.FieldWorker:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorker(v)
		return nil
	case job.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case job.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case job.FieldEntryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryID(v)
		return nil
	case job.FieldConfig:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case job.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case job.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, job.FieldCreatedBy)
	}
	if m.addworker != nil {
		fields = append(fields, job.FieldWorker)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, job.FieldDeletedBy)
	}
	if m.addtask_id != nil {
		fields = append(fields, job.FieldTaskID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldCreatedBy:
		return m.AddedCreatedBy()
	case job.FieldWorker:
		return m.AddedWorker()
	case job.FieldDeletedBy:
		return m.AddedDeletedBy()
	case job.FieldTaskID:
		return m.AddedTaskID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case job.FieldWorker:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorker(v)
		return nil
	case job.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case job.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskID(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldPayload) {
		fields = append(fields, job.FieldPayload)
	}
	if m.FieldCleared(job.FieldType) {
		fields = append(fields, job.FieldType)
	}
	if m.FieldCleared(job.FieldUpdatedAt) {
		fields = append(fields, job.FieldUpdatedAt)
	}
	if m.FieldCleared(job.FieldDeletedAt) {
		fields = append(fields, job.FieldDeletedAt)
	}
	if m.FieldCleared(job.FieldDeletedBy) {
		fields = append(fields, job.FieldDeletedBy)
	}
	if m.FieldCleared(job.FieldEntryID) {
		fields = append(fields, job.FieldEntryID)
	}
	if m.FieldCleared(job.FieldConfig) {
		fields = append(fields, job.FieldConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldPayload:
		m.ClearPayload()
		return nil
	case job.FieldType:
		m.ClearType()
		return nil
	case job.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case job.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case job.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case job.FieldEntryID:
		m.ClearEntryID()
		return nil
	case job.FieldConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case job.FieldPayload:
		m.ResetPayload()
		return nil
	case job.FieldType:
		m.ResetType()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case job.FieldWorker:
		m.ResetWorker()
		return nil
	case job.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case job.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case job.FieldEntryID:
		m.ResetEntryID()
		return nil
	case job.FieldConfig:
		m.ResetConfig()
		return nil
	case job.FieldTaskID:
		m.ResetTaskID()
		return nil
	case job.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Job edge %s", name)
}

// MetaEventMutation represents an operation that mutates the MetaEvent nodes in the graph.
type MetaEventMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	event_name    *string
	uuid          *uuid.UUID
	display_name  *string
	event_desc    *string
	remark        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MetaEvent, error)
	predicates    []predicate.MetaEvent
}

var _ ent.Mutation = (*MetaEventMutation)(nil)

// metaeventOption allows management of the mutation configuration using functional options.
type metaeventOption func(*MetaEventMutation)

// newMetaEventMutation creates new mutation for the MetaEvent entity.
func newMetaEventMutation(c config, op Op, opts ...metaeventOption) *MetaEventMutation {
	m := &MetaEventMutation{
		config:        c,
		op:            op,
		typ:           TypeMetaEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetaEventID sets the ID field of the mutation.
func withMetaEventID(id int64) metaeventOption {
	return func(m *MetaEventMutation) {
		var (
			err   error
			once  sync.Once
			value *MetaEvent
		)
		m.oldValue = func(ctx context.Context) (*MetaEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MetaEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetaEvent sets the old MetaEvent of the mutation.
func withMetaEvent(node *MetaEvent) metaeventOption {
	return func(m *MetaEventMutation) {
		m.oldValue = func(context.Context) (*MetaEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetaEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetaEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MetaEvent entities.
func (m *MetaEventMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetaEventMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetaEventMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MetaEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventName sets the "event_name" field.
func (m *MetaEventMutation) SetEventName(s string) {
	m.event_name = &s
}

// EventName returns the value of the "event_name" field in the mutation.
func (m *MetaEventMutation) EventName() (r string, exists bool) {
	v := m.event_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEventName returns the old "event_name" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldEventName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventName: %w", err)
	}
	return oldValue.EventName, nil
}

// ResetEventName resets all changes to the "event_name" field.
func (m *MetaEventMutation) ResetEventName() {
	m.event_name = nil
}

// SetUUID sets the "uuid" field.
func (m *MetaEventMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *MetaEventMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *MetaEventMutation) ResetUUID() {
	m.uuid = nil
}

// SetDisplayName sets the "display_name" field.
func (m *MetaEventMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *MetaEventMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *MetaEventMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetEventDesc sets the "event_desc" field.
func (m *MetaEventMutation) SetEventDesc(s string) {
	m.event_desc = &s
}

// EventDesc returns the value of the "event_desc" field in the mutation.
func (m *MetaEventMutation) EventDesc() (r string, exists bool) {
	v := m.event_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldEventDesc returns the old "event_desc" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldEventDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventDesc: %w", err)
	}
	return oldValue.EventDesc, nil
}

// ClearEventDesc clears the value of the "event_desc" field.
func (m *MetaEventMutation) ClearEventDesc() {
	m.event_desc = nil
	m.clearedFields[metaevent.FieldEventDesc] = struct{}{}
}

// EventDescCleared returns if the "event_desc" field was cleared in this mutation.
func (m *MetaEventMutation) EventDescCleared() bool {
	_, ok := m.clearedFields[metaevent.FieldEventDesc]
	return ok
}

// ResetEventDesc resets all changes to the "event_desc" field.
func (m *MetaEventMutation) ResetEventDesc() {
	m.event_desc = nil
	delete(m.clearedFields, metaevent.FieldEventDesc)
}

// SetRemark sets the "remark" field.
func (m *MetaEventMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MetaEventMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MetaEventMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[metaevent.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MetaEventMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[metaevent.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MetaEventMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, metaevent.FieldRemark)
}

// SetCreatedAt sets the "created_at" field.
func (m *MetaEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetaEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetaEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetaEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetaEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MetaEvent entity.
// If the MetaEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MetaEventMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[metaevent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MetaEventMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[metaevent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetaEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, metaevent.FieldUpdatedAt)
}

// Where appends a list predicates to the MetaEventMutation builder.
func (m *MetaEventMutation) Where(ps ...predicate.MetaEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetaEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetaEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MetaEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetaEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetaEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MetaEvent).
func (m *MetaEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetaEventMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.event_name != nil {
		fields = append(fields, metaevent.FieldEventName)
	}
	if m.uuid != nil {
		fields = append(fields, metaevent.FieldUUID)
	}
	if m.display_name != nil {
		fields = append(fields, metaevent.FieldDisplayName)
	}
	if m.event_desc != nil {
		fields = append(fields, metaevent.FieldEventDesc)
	}
	if m.remark != nil {
		fields = append(fields, metaevent.FieldRemark)
	}
	if m.created_at != nil {
		fields = append(fields, metaevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metaevent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetaEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metaevent.FieldEventName:
		return m.EventName()
	case metaevent.FieldUUID:
		return m.UUID()
	case metaevent.FieldDisplayName:
		return m.DisplayName()
	case metaevent.FieldEventDesc:
		return m.EventDesc()
	case metaevent.FieldRemark:
		return m.Remark()
	case metaevent.FieldCreatedAt:
		return m.CreatedAt()
	case metaevent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetaEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metaevent.FieldEventName:
		return m.OldEventName(ctx)
	case metaevent.FieldUUID:
		return m.OldUUID(ctx)
	case metaevent.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case metaevent.FieldEventDesc:
		return m.OldEventDesc(ctx)
	case metaevent.FieldRemark:
		return m.OldRemark(ctx)
	case metaevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metaevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MetaEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetaEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metaevent.FieldEventName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventName(v)
		return nil
	case metaevent.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case metaevent.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case metaevent.FieldEventDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventDesc(v)
		return nil
	case metaevent.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case metaevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metaevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MetaEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetaEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetaEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetaEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MetaEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetaEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(metaevent.FieldEventDesc) {
		fields = append(fields, metaevent.FieldEventDesc)
	}
	if m.FieldCleared(metaevent.FieldRemark) {
		fields = append(fields, metaevent.FieldRemark)
	}
	if m.FieldCleared(metaevent.FieldUpdatedAt) {
		fields = append(fields, metaevent.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetaEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetaEventMutation) ClearField(name string) error {
	switch name {
	case metaevent.FieldEventDesc:
		m.ClearEventDesc()
		return nil
	case metaevent.FieldRemark:
		m.ClearRemark()
		return nil
	case metaevent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MetaEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetaEventMutation) ResetField(name string) error {
	switch name {
	case metaevent.FieldEventName:
		m.ResetEventName()
		return nil
	case metaevent.FieldUUID:
		m.ResetUUID()
		return nil
	case metaevent.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case metaevent.FieldEventDesc:
		m.ResetEventDesc()
		return nil
	case metaevent.FieldRemark:
		m.ResetRemark()
		return nil
	case metaevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metaevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MetaEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetaEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetaEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetaEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetaEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetaEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetaEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetaEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MetaEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetaEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MetaEvent edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	identifier    *string
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	updated_at    *time.Time
	updated_by    *uint32
	addupdated_by *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	status        *int8
	addstatus     *int8
	start_time    *time.Time
	deadline      *time.Time
	description   *string
	remark        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Project, error)
	predicates    []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int64) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetIdentifier sets the "identifier" field.
func (m *ProjectMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *ProjectMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *ProjectMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *ProjectMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProjectMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ProjectMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[project.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ProjectMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, project.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *ProjectMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *ProjectMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *ProjectMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *ProjectMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *ProjectMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[project.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *ProjectMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[project.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *ProjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, project.FieldUpdatedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProjectMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProjectMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *ProjectMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *ProjectMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProjectMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[project.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProjectMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProjectMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, project.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProjectMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProjectMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetStartTime sets the "start_time" field.
func (m *ProjectMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ProjectMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ProjectMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[project.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ProjectMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[project.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ProjectMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, project.FieldStartTime)
}

// SetDeadline sets the "deadline" field.
func (m *ProjectMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *ProjectMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *ProjectMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[project.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *ProjectMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[project.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *ProjectMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, project.FieldDeadline)
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetRemark sets the "remark" field.
func (m *ProjectMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ProjectMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ProjectMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[project.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ProjectMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[project.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ProjectMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, project.FieldRemark)
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.identifier != nil {
		fields = append(fields, project.FieldIdentifier)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, project.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	if m.start_time != nil {
		fields = append(fields, project.FieldStartTime)
	}
	if m.deadline != nil {
		fields = append(fields, project.FieldDeadline)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.remark != nil {
		fields = append(fields, project.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldIdentifier:
		return m.Identifier()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldCreatedBy:
		return m.CreatedBy()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldUpdatedBy:
		return m.UpdatedBy()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldDeletedBy:
		return m.DeletedBy()
	case project.FieldStatus:
		return m.Status()
	case project.FieldStartTime:
		return m.StartTime()
	case project.FieldDeadline:
		return m.Deadline()
	case project.FieldDescription:
		return m.Description()
	case project.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	case project.FieldStartTime:
		return m.OldStartTime(ctx)
	case project.FieldDeadline:
		return m.OldDeadline(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case project.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case project.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, project.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, project.FieldDeletedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, project.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedBy:
		return m.AddedCreatedBy()
	case project.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case project.FieldDeletedBy:
		return m.AddedDeletedBy()
	case project.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case project.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case project.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldUpdatedAt) {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.FieldCleared(project.FieldUpdatedBy) {
		fields = append(fields, project.FieldUpdatedBy)
	}
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.FieldCleared(project.FieldDeletedBy) {
		fields = append(fields, project.FieldDeletedBy)
	}
	if m.FieldCleared(project.FieldStartTime) {
		fields = append(fields, project.FieldStartTime)
	}
	if m.FieldCleared(project.FieldDeadline) {
		fields = append(fields, project.FieldDeadline)
	}
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldRemark) {
		fields = append(fields, project.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case project.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case project.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case project.FieldStartTime:
		m.ClearStartTime()
		return nil
	case project.FieldDeadline:
		m.ClearDeadline()
		return nil
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	case project.FieldStartTime:
		m.ResetStartTime()
		return nil
	case project.FieldDeadline:
		m.ResetDeadline()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectMemberMutation represents an operation that mutates the ProjectMember nodes in the graph.
type ProjectMemberMutation struct {
	config
	op            Op
	typ           string
	id            *int
	project_id    *int64
	addproject_id *int64
	user_id       *uint32
	adduser_id    *int32
	created_at    *time.Time
	created_by    *uint32
	addcreated_by *int32
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	status        *int8
	addstatus     *int8
	description   *string
	remark        *string
	role          *uint8
	addrole       *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProjectMember, error)
	predicates    []predicate.ProjectMember
}

var _ ent.Mutation = (*ProjectMemberMutation)(nil)

// projectmemberOption allows management of the mutation configuration using functional options.
type projectmemberOption func(*ProjectMemberMutation)

// newProjectMemberMutation creates new mutation for the ProjectMember entity.
func newProjectMemberMutation(c config, op Op, opts ...projectmemberOption) *ProjectMemberMutation {
	m := &ProjectMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectMemberID sets the ID field of the mutation.
func withProjectMemberID(id int) projectmemberOption {
	return func(m *ProjectMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectMember
		)
		m.oldValue = func(ctx context.Context) (*ProjectMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectMember sets the old ProjectMember of the mutation.
func withProjectMember(node *ProjectMember) projectmemberOption {
	return func(m *ProjectMemberMutation) {
		m.oldValue = func(context.Context) (*ProjectMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectMemberMutation) SetProjectID(i int64) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectMemberMutation) ProjectID() (r int64, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *ProjectMemberMutation) AddProjectID(i int64) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *ProjectMemberMutation) AddedProjectID() (r int64, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectMemberMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// SetUserID sets the "user_id" field.
func (m *ProjectMemberMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProjectMemberMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *ProjectMemberMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ProjectMemberMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProjectMemberMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProjectMemberMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProjectMemberMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *ProjectMemberMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *ProjectMemberMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProjectMemberMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMemberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMemberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMemberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[projectmember.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMemberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[projectmember.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMemberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, projectmember.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *ProjectMemberMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *ProjectMemberMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *ProjectMemberMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *ProjectMemberMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *ProjectMemberMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[projectmember.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *ProjectMemberMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[projectmember.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *ProjectMemberMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, projectmember.FieldDeletedBy)
}

// SetStatus sets the "status" field.
func (m *ProjectMemberMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMemberMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProjectMemberMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProjectMemberMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMemberMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMemberMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMemberMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMemberMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projectmember.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMemberMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projectmember.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMemberMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projectmember.FieldDescription)
}

// SetRemark sets the "remark" field.
func (m *ProjectMemberMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ProjectMemberMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ProjectMemberMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[projectmember.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ProjectMemberMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[projectmember.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ProjectMemberMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, projectmember.FieldRemark)
}

// SetRole sets the "role" field.
func (m *ProjectMemberMutation) SetRole(u uint8) {
	m.role = &u
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *ProjectMemberMutation) Role() (r uint8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldRole(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds u to the "role" field.
func (m *ProjectMemberMutation) AddRole(u int8) {
	if m.addrole != nil {
		*m.addrole += u
	} else {
		m.addrole = &u
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *ProjectMemberMutation) AddedRole() (r int8, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *ProjectMemberMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// Where appends a list predicates to the ProjectMemberMutation builder.
func (m *ProjectMemberMutation) Where(ps ...predicate.ProjectMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectMember).
func (m *ProjectMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMemberMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.project_id != nil {
		fields = append(fields, projectmember.FieldProjectID)
	}
	if m.user_id != nil {
		fields = append(fields, projectmember.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, projectmember.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, projectmember.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, projectmember.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, projectmember.FieldDeletedBy)
	}
	if m.status != nil {
		fields = append(fields, projectmember.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, projectmember.FieldDescription)
	}
	if m.remark != nil {
		fields = append(fields, projectmember.FieldRemark)
	}
	if m.role != nil {
		fields = append(fields, projectmember.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectmember.FieldProjectID:
		return m.ProjectID()
	case projectmember.FieldUserID:
		return m.UserID()
	case projectmember.FieldCreatedAt:
		return m.CreatedAt()
	case projectmember.FieldCreatedBy:
		return m.CreatedBy()
	case projectmember.FieldDeletedAt:
		return m.DeletedAt()
	case projectmember.FieldDeletedBy:
		return m.DeletedBy()
	case projectmember.FieldStatus:
		return m.Status()
	case projectmember.FieldDescription:
		return m.Description()
	case projectmember.FieldRemark:
		return m.Remark()
	case projectmember.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectmember.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectmember.FieldUserID:
		return m.OldUserID(ctx)
	case projectmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectmember.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case projectmember.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case projectmember.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case projectmember.FieldStatus:
		return m.OldStatus(ctx)
	case projectmember.FieldDescription:
		return m.OldDescription(ctx)
	case projectmember.FieldRemark:
		return m.OldRemark(ctx)
	case projectmember.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectmember.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectmember.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case projectmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectmember.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case projectmember.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case projectmember.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case projectmember.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case projectmember.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projectmember.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case projectmember.FieldRole:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMemberMutation) AddedFields() []string {
	var fields []string
	if m.addproject_id != nil {
		fields = append(fields, projectmember.FieldProjectID)
	}
	if m.adduser_id != nil {
		fields = append(fields, projectmember.FieldUserID)
	}
	if m.addcreated_by != nil {
		fields = append(fields, projectmember.FieldCreatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, projectmember.FieldDeletedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, projectmember.FieldStatus)
	}
	if m.addrole != nil {
		fields = append(fields, projectmember.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projectmember.FieldProjectID:
		return m.AddedProjectID()
	case projectmember.FieldUserID:
		return m.AddedUserID()
	case projectmember.FieldCreatedBy:
		return m.AddedCreatedBy()
	case projectmember.FieldDeletedBy:
		return m.AddedDeletedBy()
	case projectmember.FieldStatus:
		return m.AddedStatus()
	case projectmember.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projectmember.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	case projectmember.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case projectmember.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case projectmember.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case projectmember.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case projectmember.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectmember.FieldDeletedAt) {
		fields = append(fields, projectmember.FieldDeletedAt)
	}
	if m.FieldCleared(projectmember.FieldDeletedBy) {
		fields = append(fields, projectmember.FieldDeletedBy)
	}
	if m.FieldCleared(projectmember.FieldDescription) {
		fields = append(fields, projectmember.FieldDescription)
	}
	if m.FieldCleared(projectmember.FieldRemark) {
		fields = append(fields, projectmember.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMemberMutation) ClearField(name string) error {
	switch name {
	case projectmember.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case projectmember.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case projectmember.FieldDescription:
		m.ClearDescription()
		return nil
	case projectmember.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ProjectMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMemberMutation) ResetField(name string) error {
	switch name {
	case projectmember.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectmember.FieldUserID:
		m.ResetUserID()
		return nil
	case projectmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectmember.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case projectmember.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case projectmember.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case projectmember.FieldStatus:
		m.ResetStatus()
		return nil
	case projectmember.FieldDescription:
		m.ResetDescription()
		return nil
	case projectmember.FieldRemark:
		m.ResetRemark()
		return nil
	case projectmember.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown ProjectMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMemberMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMemberMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMemberMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProjectMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMemberMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProjectMember edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	name                 *string
	created_at           *time.Time
	created_by           *uint32
	addcreated_by        *int32
	assignee             *uint32
	addassignee          *int32
	_type                *int8
	add_type             *int8
	frequency            *int8
	addfrequency         *int8
	schedule_time        *time.Time
	rank                 *int8
	addrank              *int8
	status               *int8
	addstatus            *int8
	start_time           *time.Time
	completed_at         *time.Time
	updated_at           *time.Time
	updated_by           *uint32
	addupdated_by        *int32
	status_updated_at    *time.Time
	deadline             *time.Time
	deleted_at           *time.Time
	deleted_by           *uint32
	adddeleted_by        *int32
	description          *string
	testplan_id          *int64
	addtestplan_id       *int64
	testcase_suite       *[]int64
	appendtestcase_suite []int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Task, error)
	predicates           []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TaskMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TaskMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetAssignee sets the "assignee" field.
func (m *TaskMutation) SetAssignee(u uint32) {
	m.assignee = &u
	m.addassignee = nil
}

// Assignee returns the value of the "assignee" field in the mutation.
func (m *TaskMutation) Assignee() (r uint32, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignee returns the old "assignee" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssignee(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignee: %w", err)
	}
	return oldValue.Assignee, nil
}

// AddAssignee adds u to the "assignee" field.
func (m *TaskMutation) AddAssignee(u int32) {
	if m.addassignee != nil {
		*m.addassignee += u
	} else {
		m.addassignee = &u
	}
}

// AddedAssignee returns the value that was added to the "assignee" field in this mutation.
func (m *TaskMutation) AddedAssignee() (r int32, exists bool) {
	v := m.addassignee
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssignee clears the value of the "assignee" field.
func (m *TaskMutation) ClearAssignee() {
	m.assignee = nil
	m.addassignee = nil
	m.clearedFields[task.FieldAssignee] = struct{}{}
}

// AssigneeCleared returns if the "assignee" field was cleared in this mutation.
func (m *TaskMutation) AssigneeCleared() bool {
	_, ok := m.clearedFields[task.FieldAssignee]
	return ok
}

// ResetAssignee resets all changes to the "assignee" field.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	m.addassignee = nil
	delete(m.clearedFields, task.FieldAssignee)
}

// SetType sets the "type" field.
func (m *TaskMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TaskMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TaskMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TaskMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetFrequency sets the "frequency" field.
func (m *TaskMutation) SetFrequency(i int8) {
	m.frequency = &i
	m.addfrequency = nil
}

// Frequency returns the value of the "frequency" field in the mutation.
func (m *TaskMutation) Frequency() (r int8, exists bool) {
	v := m.frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequency returns the old "frequency" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldFrequency(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequency: %w", err)
	}
	return oldValue.Frequency, nil
}

// AddFrequency adds i to the "frequency" field.
func (m *TaskMutation) AddFrequency(i int8) {
	if m.addfrequency != nil {
		*m.addfrequency += i
	} else {
		m.addfrequency = &i
	}
}

// AddedFrequency returns the value that was added to the "frequency" field in this mutation.
func (m *TaskMutation) AddedFrequency() (r int8, exists bool) {
	v := m.addfrequency
	if v == nil {
		return
	}
	return *v, true
}

// ClearFrequency clears the value of the "frequency" field.
func (m *TaskMutation) ClearFrequency() {
	m.frequency = nil
	m.addfrequency = nil
	m.clearedFields[task.FieldFrequency] = struct{}{}
}

// FrequencyCleared returns if the "frequency" field was cleared in this mutation.
func (m *TaskMutation) FrequencyCleared() bool {
	_, ok := m.clearedFields[task.FieldFrequency]
	return ok
}

// ResetFrequency resets all changes to the "frequency" field.
func (m *TaskMutation) ResetFrequency() {
	m.frequency = nil
	m.addfrequency = nil
	delete(m.clearedFields, task.FieldFrequency)
}

// SetScheduleTime sets the "schedule_time" field.
func (m *TaskMutation) SetScheduleTime(t time.Time) {
	m.schedule_time = &t
}

// ScheduleTime returns the value of the "schedule_time" field in the mutation.
func (m *TaskMutation) ScheduleTime() (r time.Time, exists bool) {
	v := m.schedule_time
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleTime returns the old "schedule_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScheduleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleTime: %w", err)
	}
	return oldValue.ScheduleTime, nil
}

// ClearScheduleTime clears the value of the "schedule_time" field.
func (m *TaskMutation) ClearScheduleTime() {
	m.schedule_time = nil
	m.clearedFields[task.FieldScheduleTime] = struct{}{}
}

// ScheduleTimeCleared returns if the "schedule_time" field was cleared in this mutation.
func (m *TaskMutation) ScheduleTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldScheduleTime]
	return ok
}

// ResetScheduleTime resets all changes to the "schedule_time" field.
func (m *TaskMutation) ResetScheduleTime() {
	m.schedule_time = nil
	delete(m.clearedFields, task.FieldScheduleTime)
}

// SetRank sets the "rank" field.
func (m *TaskMutation) SetRank(i int8) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *TaskMutation) Rank() (r int8, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldRank(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *TaskMutation) AddRank(i int8) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *TaskMutation) AddedRank() (r int8, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *TaskMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TaskMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TaskMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetStartTime sets the "start_time" field.
func (m *TaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *TaskMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[task.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *TaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TaskMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, task.FieldStartTime)
}

// SetCompletedAt sets the "completed_at" field.
func (m *TaskMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *TaskMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCompletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *TaskMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[task.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *TaskMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *TaskMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, task.FieldCompletedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TaskMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[task.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TaskMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, task.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TaskMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TaskMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TaskMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[task.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TaskMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[task.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, task.FieldUpdatedBy)
}

// SetStatusUpdatedAt sets the "status_updated_at" field.
func (m *TaskMutation) SetStatusUpdatedAt(t time.Time) {
	m.status_updated_at = &t
}

// StatusUpdatedAt returns the value of the "status_updated_at" field in the mutation.
func (m *TaskMutation) StatusUpdatedAt() (r time.Time, exists bool) {
	v := m.status_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusUpdatedAt returns the old "status_updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatusUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusUpdatedAt: %w", err)
	}
	return oldValue.StatusUpdatedAt, nil
}

// ClearStatusUpdatedAt clears the value of the "status_updated_at" field.
func (m *TaskMutation) ClearStatusUpdatedAt() {
	m.status_updated_at = nil
	m.clearedFields[task.FieldStatusUpdatedAt] = struct{}{}
}

// StatusUpdatedAtCleared returns if the "status_updated_at" field was cleared in this mutation.
func (m *TaskMutation) StatusUpdatedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldStatusUpdatedAt]
	return ok
}

// ResetStatusUpdatedAt resets all changes to the "status_updated_at" field.
func (m *TaskMutation) ResetStatusUpdatedAt() {
	m.status_updated_at = nil
	delete(m.clearedFields, task.FieldStatusUpdatedAt)
}

// SetDeadline sets the "deadline" field.
func (m *TaskMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *TaskMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *TaskMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[task.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *TaskMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[task.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *TaskMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, task.FieldDeadline)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TaskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TaskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TaskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[task.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TaskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TaskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, task.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TaskMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TaskMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *TaskMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TaskMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TaskMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[task.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TaskMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[task.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TaskMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, task.FieldDeletedBy)
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetTestplanID sets the "testplan_id" field.
func (m *TaskMutation) SetTestplanID(i int64) {
	m.testplan_id = &i
	m.addtestplan_id = nil
}

// TestplanID returns the value of the "testplan_id" field in the mutation.
func (m *TaskMutation) TestplanID() (r int64, exists bool) {
	v := m.testplan_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTestplanID returns the old "testplan_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTestplanID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestplanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestplanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestplanID: %w", err)
	}
	return oldValue.TestplanID, nil
}

// AddTestplanID adds i to the "testplan_id" field.
func (m *TaskMutation) AddTestplanID(i int64) {
	if m.addtestplan_id != nil {
		*m.addtestplan_id += i
	} else {
		m.addtestplan_id = &i
	}
}

// AddedTestplanID returns the value that was added to the "testplan_id" field in this mutation.
func (m *TaskMutation) AddedTestplanID() (r int64, exists bool) {
	v := m.addtestplan_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTestplanID clears the value of the "testplan_id" field.
func (m *TaskMutation) ClearTestplanID() {
	m.testplan_id = nil
	m.addtestplan_id = nil
	m.clearedFields[task.FieldTestplanID] = struct{}{}
}

// TestplanIDCleared returns if the "testplan_id" field was cleared in this mutation.
func (m *TaskMutation) TestplanIDCleared() bool {
	_, ok := m.clearedFields[task.FieldTestplanID]
	return ok
}

// ResetTestplanID resets all changes to the "testplan_id" field.
func (m *TaskMutation) ResetTestplanID() {
	m.testplan_id = nil
	m.addtestplan_id = nil
	delete(m.clearedFields, task.FieldTestplanID)
}

// SetTestcaseSuite sets the "testcase_suite" field.
func (m *TaskMutation) SetTestcaseSuite(i []int64) {
	m.testcase_suite = &i
	m.appendtestcase_suite = nil
}

// TestcaseSuite returns the value of the "testcase_suite" field in the mutation.
func (m *TaskMutation) TestcaseSuite() (r []int64, exists bool) {
	v := m.testcase_suite
	if v == nil {
		return
	}
	return *v, true
}

// OldTestcaseSuite returns the old "testcase_suite" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTestcaseSuite(ctx context.Context) (v []int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestcaseSuite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestcaseSuite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestcaseSuite: %w", err)
	}
	return oldValue.TestcaseSuite, nil
}

// AppendTestcaseSuite adds i to the "testcase_suite" field.
func (m *TaskMutation) AppendTestcaseSuite(i []int64) {
	m.appendtestcase_suite = append(m.appendtestcase_suite, i...)
}

// AppendedTestcaseSuite returns the list of values that were appended to the "testcase_suite" field in this mutation.
func (m *TaskMutation) AppendedTestcaseSuite() ([]int64, bool) {
	if len(m.appendtestcase_suite) == 0 {
		return nil, false
	}
	return m.appendtestcase_suite, true
}

// ClearTestcaseSuite clears the value of the "testcase_suite" field.
func (m *TaskMutation) ClearTestcaseSuite() {
	m.testcase_suite = nil
	m.appendtestcase_suite = nil
	m.clearedFields[task.FieldTestcaseSuite] = struct{}{}
}

// TestcaseSuiteCleared returns if the "testcase_suite" field was cleared in this mutation.
func (m *TaskMutation) TestcaseSuiteCleared() bool {
	_, ok := m.clearedFields[task.FieldTestcaseSuite]
	return ok
}

// ResetTestcaseSuite resets all changes to the "testcase_suite" field.
func (m *TaskMutation) ResetTestcaseSuite() {
	m.testcase_suite = nil
	m.appendtestcase_suite = nil
	delete(m.clearedFields, task.FieldTestcaseSuite)
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.assignee != nil {
		fields = append(fields, task.FieldAssignee)
	}
	if m._type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.frequency != nil {
		fields = append(fields, task.FieldFrequency)
	}
	if m.schedule_time != nil {
		fields = append(fields, task.FieldScheduleTime)
	}
	if m.rank != nil {
		fields = append(fields, task.FieldRank)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.start_time != nil {
		fields = append(fields, task.FieldStartTime)
	}
	if m.completed_at != nil {
		fields = append(fields, task.FieldCompletedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.status_updated_at != nil {
		fields = append(fields, task.FieldStatusUpdatedAt)
	}
	if m.deadline != nil {
		fields = append(fields, task.FieldDeadline)
	}
	if m.deleted_at != nil {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.testplan_id != nil {
		fields = append(fields, task.FieldTestplanID)
	}
	if m.testcase_suite != nil {
		fields = append(fields, task.FieldTestcaseSuite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldName:
		return m.Name()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldAssignee:
		return m.Assignee()
	case task.FieldType:
		return m.GetType()
	case task.FieldFrequency:
		return m.Frequency()
	case task.FieldScheduleTime:
		return m.ScheduleTime()
	case task.FieldRank:
		return m.Rank()
	case task.FieldStatus:
		return m.Status()
	case task.FieldStartTime:
		return m.StartTime()
	case task.FieldCompletedAt:
		return m.CompletedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldStatusUpdatedAt:
		return m.StatusUpdatedAt()
	case task.FieldDeadline:
		return m.Deadline()
	case task.FieldDeletedAt:
		return m.DeletedAt()
	case task.FieldDeletedBy:
		return m.DeletedBy()
	case task.FieldDescription:
		return m.Description()
	case task.FieldTestplanID:
		return m.TestplanID()
	case task.FieldTestcaseSuite:
		return m.TestcaseSuite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldAssignee:
		return m.OldAssignee(ctx)
	case task.FieldType:
		return m.OldType(ctx)
	case task.FieldFrequency:
		return m.OldFrequency(ctx)
	case task.FieldScheduleTime:
		return m.OldScheduleTime(ctx)
	case task.FieldRank:
		return m.OldRank(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	case task.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldStatusUpdatedAt:
		return m.OldStatusUpdatedAt(ctx)
	case task.FieldDeadline:
		return m.OldDeadline(ctx)
	case task.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case task.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldTestplanID:
		return m.OldTestplanID(ctx)
	case task.FieldTestcaseSuite:
		return m.OldTestcaseSuite(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldAssignee:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignee(v)
		return nil
	case task.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case task.FieldFrequency:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequency(v)
		return nil
	case task.FieldScheduleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleTime(v)
		return nil
	case task.FieldRank:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case task.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldStatusUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusUpdatedAt(v)
		return nil
	case task.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case task.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case task.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldTestplanID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestplanID(v)
		return nil
	case task.FieldTestcaseSuite:
		v, ok := value.([]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestcaseSuite(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.addassignee != nil {
		fields = append(fields, task.FieldAssignee)
	}
	if m.add_type != nil {
		fields = append(fields, task.FieldType)
	}
	if m.addfrequency != nil {
		fields = append(fields, task.FieldFrequency)
	}
	if m.addrank != nil {
		fields = append(fields, task.FieldRank)
	}
	if m.addstatus != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.addupdated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.addtestplan_id != nil {
		fields = append(fields, task.FieldTestplanID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedBy:
		return m.AddedCreatedBy()
	case task.FieldAssignee:
		return m.AddedAssignee()
	case task.FieldType:
		return m.AddedType()
	case task.FieldFrequency:
		return m.AddedFrequency()
	case task.FieldRank:
		return m.AddedRank()
	case task.FieldStatus:
		return m.AddedStatus()
	case task.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case task.FieldDeletedBy:
		return m.AddedDeletedBy()
	case task.FieldTestplanID:
		return m.AddedTestplanID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case task.FieldAssignee:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssignee(v)
		return nil
	case task.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case task.FieldFrequency:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrequency(v)
		return nil
	case task.FieldRank:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case task.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case task.FieldTestplanID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestplanID(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldAssignee) {
		fields = append(fields, task.FieldAssignee)
	}
	if m.FieldCleared(task.FieldFrequency) {
		fields = append(fields, task.FieldFrequency)
	}
	if m.FieldCleared(task.FieldScheduleTime) {
		fields = append(fields, task.FieldScheduleTime)
	}
	if m.FieldCleared(task.FieldStartTime) {
		fields = append(fields, task.FieldStartTime)
	}
	if m.FieldCleared(task.FieldCompletedAt) {
		fields = append(fields, task.FieldCompletedAt)
	}
	if m.FieldCleared(task.FieldUpdatedAt) {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.FieldCleared(task.FieldUpdatedBy) {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.FieldCleared(task.FieldStatusUpdatedAt) {
		fields = append(fields, task.FieldStatusUpdatedAt)
	}
	if m.FieldCleared(task.FieldDeadline) {
		fields = append(fields, task.FieldDeadline)
	}
	if m.FieldCleared(task.FieldDeletedAt) {
		fields = append(fields, task.FieldDeletedAt)
	}
	if m.FieldCleared(task.FieldDeletedBy) {
		fields = append(fields, task.FieldDeletedBy)
	}
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	if m.FieldCleared(task.FieldTestplanID) {
		fields = append(fields, task.FieldTestplanID)
	}
	if m.FieldCleared(task.FieldTestcaseSuite) {
		fields = append(fields, task.FieldTestcaseSuite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldAssignee:
		m.ClearAssignee()
		return nil
	case task.FieldFrequency:
		m.ClearFrequency()
		return nil
	case task.FieldScheduleTime:
		m.ClearScheduleTime()
		return nil
	case task.FieldStartTime:
		m.ClearStartTime()
		return nil
	case task.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case task.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case task.FieldStatusUpdatedAt:
		m.ClearStatusUpdatedAt()
		return nil
	case task.FieldDeadline:
		m.ClearDeadline()
		return nil
	case task.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case task.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	case task.FieldTestplanID:
		m.ClearTestplanID()
		return nil
	case task.FieldTestcaseSuite:
		m.ClearTestcaseSuite()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldAssignee:
		m.ResetAssignee()
		return nil
	case task.FieldType:
		m.ResetType()
		return nil
	case task.FieldFrequency:
		m.ResetFrequency()
		return nil
	case task.FieldScheduleTime:
		m.ResetScheduleTime()
		return nil
	case task.FieldRank:
		m.ResetRank()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	case task.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldStatusUpdatedAt:
		m.ResetStatusUpdatedAt()
		return nil
	case task.FieldDeadline:
		m.ResetDeadline()
		return nil
	case task.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case task.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldTestplanID:
		m.ResetTestplanID()
		return nil
	case task.FieldTestcaseSuite:
		m.ResetTestcaseSuite()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// TestPlanMutation represents an operation that mutates the TestPlan nodes in the graph.
type TestPlanMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	created_at        *time.Time
	created_by        *uint32
	addcreated_by     *int32
	updated_at        *time.Time
	updated_by        *uint32
	addupdated_by     *int32
	description       *string
	start_time        *time.Time
	deadline          *time.Time
	status_updated_at *time.Time
	status            *int8
	addstatus         *int8
	tasks             *[]int32
	appendtasks       []int32
	project_id        *int32
	addproject_id     *int32
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*TestPlan, error)
	predicates        []predicate.TestPlan
}

var _ ent.Mutation = (*TestPlanMutation)(nil)

// testplanOption allows management of the mutation configuration using functional options.
type testplanOption func(*TestPlanMutation)

// newTestPlanMutation creates new mutation for the TestPlan entity.
func newTestPlanMutation(c config, op Op, opts ...testplanOption) *TestPlanMutation {
	m := &TestPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeTestPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestPlanID sets the ID field of the mutation.
func withTestPlanID(id int64) testplanOption {
	return func(m *TestPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *TestPlan
		)
		m.oldValue = func(ctx context.Context) (*TestPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestPlan sets the old TestPlan of the mutation.
func withTestPlan(node *TestPlan) testplanOption {
	return func(m *TestPlanMutation) {
		m.oldValue = func(context.Context) (*TestPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestPlan entities.
func (m *TestPlanMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestPlanMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestPlanMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TestPlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestPlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestPlanMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestPlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TestPlanMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TestPlanMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TestPlanMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TestPlanMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TestPlanMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TestPlanMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[testplan.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TestPlanMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[testplan.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, testplan.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TestPlanMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TestPlanMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TestPlanMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TestPlanMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TestPlanMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[testplan.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TestPlanMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[testplan.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TestPlanMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, testplan.FieldUpdatedBy)
}

// SetDescription sets the "description" field.
func (m *TestPlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TestPlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TestPlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[testplan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TestPlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[testplan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TestPlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, testplan.FieldDescription)
}

// SetStartTime sets the "start_time" field.
func (m *TestPlanMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *TestPlanMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *TestPlanMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[testplan.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *TestPlanMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[testplan.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *TestPlanMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, testplan.FieldStartTime)
}

// SetDeadline sets the "deadline" field.
func (m *TestPlanMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *TestPlanMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *TestPlanMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[testplan.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *TestPlanMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[testplan.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *TestPlanMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, testplan.FieldDeadline)
}

// SetStatusUpdatedAt sets the "status_updated_at" field.
func (m *TestPlanMutation) SetStatusUpdatedAt(t time.Time) {
	m.status_updated_at = &t
}

// StatusUpdatedAt returns the value of the "status_updated_at" field in the mutation.
func (m *TestPlanMutation) StatusUpdatedAt() (r time.Time, exists bool) {
	v := m.status_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusUpdatedAt returns the old "status_updated_at" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldStatusUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusUpdatedAt: %w", err)
	}
	return oldValue.StatusUpdatedAt, nil
}

// ClearStatusUpdatedAt clears the value of the "status_updated_at" field.
func (m *TestPlanMutation) ClearStatusUpdatedAt() {
	m.status_updated_at = nil
	m.clearedFields[testplan.FieldStatusUpdatedAt] = struct{}{}
}

// StatusUpdatedAtCleared returns if the "status_updated_at" field was cleared in this mutation.
func (m *TestPlanMutation) StatusUpdatedAtCleared() bool {
	_, ok := m.clearedFields[testplan.FieldStatusUpdatedAt]
	return ok
}

// ResetStatusUpdatedAt resets all changes to the "status_updated_at" field.
func (m *TestPlanMutation) ResetStatusUpdatedAt() {
	m.status_updated_at = nil
	delete(m.clearedFields, testplan.FieldStatusUpdatedAt)
}

// SetStatus sets the "status" field.
func (m *TestPlanMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TestPlanMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TestPlanMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TestPlanMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TestPlanMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTasks sets the "tasks" field.
func (m *TestPlanMutation) SetTasks(i []int32) {
	m.tasks = &i
	m.appendtasks = nil
}

// Tasks returns the value of the "tasks" field in the mutation.
func (m *TestPlanMutation) Tasks() (r []int32, exists bool) {
	v := m.tasks
	if v == nil {
		return
	}
	return *v, true
}

// OldTasks returns the old "tasks" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldTasks(ctx context.Context) (v []int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTasks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTasks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTasks: %w", err)
	}
	return oldValue.Tasks, nil
}

// AppendTasks adds i to the "tasks" field.
func (m *TestPlanMutation) AppendTasks(i []int32) {
	m.appendtasks = append(m.appendtasks, i...)
}

// AppendedTasks returns the list of values that were appended to the "tasks" field in this mutation.
func (m *TestPlanMutation) AppendedTasks() ([]int32, bool) {
	if len(m.appendtasks) == 0 {
		return nil, false
	}
	return m.appendtasks, true
}

// ClearTasks clears the value of the "tasks" field.
func (m *TestPlanMutation) ClearTasks() {
	m.tasks = nil
	m.appendtasks = nil
	m.clearedFields[testplan.FieldTasks] = struct{}{}
}

// TasksCleared returns if the "tasks" field was cleared in this mutation.
func (m *TestPlanMutation) TasksCleared() bool {
	_, ok := m.clearedFields[testplan.FieldTasks]
	return ok
}

// ResetTasks resets all changes to the "tasks" field.
func (m *TestPlanMutation) ResetTasks() {
	m.tasks = nil
	m.appendtasks = nil
	delete(m.clearedFields, testplan.FieldTasks)
}

// SetProjectID sets the "project_id" field.
func (m *TestPlanMutation) SetProjectID(i int32) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TestPlanMutation) ProjectID() (r int32, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TestPlan entity.
// If the TestPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestPlanMutation) OldProjectID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *TestPlanMutation) AddProjectID(i int32) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *TestPlanMutation) AddedProjectID() (r int32, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TestPlanMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
}

// Where appends a list predicates to the TestPlanMutation builder.
func (m *TestPlanMutation) Where(ps ...predicate.TestPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestPlan).
func (m *TestPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestPlanMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, testplan.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, testplan.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, testplan.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, testplan.FieldUpdatedBy)
	}
	if m.description != nil {
		fields = append(fields, testplan.FieldDescription)
	}
	if m.start_time != nil {
		fields = append(fields, testplan.FieldStartTime)
	}
	if m.deadline != nil {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.status_updated_at != nil {
		fields = append(fields, testplan.FieldStatusUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, testplan.FieldStatus)
	}
	if m.tasks != nil {
		fields = append(fields, testplan.FieldTasks)
	}
	if m.project_id != nil {
		fields = append(fields, testplan.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldName:
		return m.Name()
	case testplan.FieldCreatedAt:
		return m.CreatedAt()
	case testplan.FieldCreatedBy:
		return m.CreatedBy()
	case testplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case testplan.FieldUpdatedBy:
		return m.UpdatedBy()
	case testplan.FieldDescription:
		return m.Description()
	case testplan.FieldStartTime:
		return m.StartTime()
	case testplan.FieldDeadline:
		return m.Deadline()
	case testplan.FieldStatusUpdatedAt:
		return m.StatusUpdatedAt()
	case testplan.FieldStatus:
		return m.Status()
	case testplan.FieldTasks:
		return m.Tasks()
	case testplan.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testplan.FieldName:
		return m.OldName(ctx)
	case testplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testplan.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case testplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testplan.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case testplan.FieldDescription:
		return m.OldDescription(ctx)
	case testplan.FieldStartTime:
		return m.OldStartTime(ctx)
	case testplan.FieldDeadline:
		return m.OldDeadline(ctx)
	case testplan.FieldStatusUpdatedAt:
		return m.OldStatusUpdatedAt(ctx)
	case testplan.FieldStatus:
		return m.OldStatus(ctx)
	case testplan.FieldTasks:
		return m.OldTasks(ctx)
	case testplan.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown TestPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testplan.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case testplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testplan.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case testplan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case testplan.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case testplan.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case testplan.FieldStatusUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusUpdatedAt(v)
		return nil
	case testplan.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case testplan.FieldTasks:
		v, ok := value.([]int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTasks(v)
		return nil
	case testplan.FieldProjectID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestPlanMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, testplan.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, testplan.FieldUpdatedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, testplan.FieldStatus)
	}
	if m.addproject_id != nil {
		fields = append(fields, testplan.FieldProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testplan.FieldCreatedBy:
		return m.AddedCreatedBy()
	case testplan.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case testplan.FieldStatus:
		return m.AddedStatus()
	case testplan.FieldProjectID:
		return m.AddedProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testplan.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case testplan.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case testplan.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case testplan.FieldProjectID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown TestPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testplan.FieldUpdatedAt) {
		fields = append(fields, testplan.FieldUpdatedAt)
	}
	if m.FieldCleared(testplan.FieldUpdatedBy) {
		fields = append(fields, testplan.FieldUpdatedBy)
	}
	if m.FieldCleared(testplan.FieldDescription) {
		fields = append(fields, testplan.FieldDescription)
	}
	if m.FieldCleared(testplan.FieldStartTime) {
		fields = append(fields, testplan.FieldStartTime)
	}
	if m.FieldCleared(testplan.FieldDeadline) {
		fields = append(fields, testplan.FieldDeadline)
	}
	if m.FieldCleared(testplan.FieldStatusUpdatedAt) {
		fields = append(fields, testplan.FieldStatusUpdatedAt)
	}
	if m.FieldCleared(testplan.FieldTasks) {
		fields = append(fields, testplan.FieldTasks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestPlanMutation) ClearField(name string) error {
	switch name {
	case testplan.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case testplan.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case testplan.FieldDescription:
		m.ClearDescription()
		return nil
	case testplan.FieldStartTime:
		m.ClearStartTime()
		return nil
	case testplan.FieldDeadline:
		m.ClearDeadline()
		return nil
	case testplan.FieldStatusUpdatedAt:
		m.ClearStatusUpdatedAt()
		return nil
	case testplan.FieldTasks:
		m.ClearTasks()
		return nil
	}
	return fmt.Errorf("unknown TestPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestPlanMutation) ResetField(name string) error {
	switch name {
	case testplan.FieldName:
		m.ResetName()
		return nil
	case testplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testplan.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case testplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testplan.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case testplan.FieldDescription:
		m.ResetDescription()
		return nil
	case testplan.FieldStartTime:
		m.ResetStartTime()
		return nil
	case testplan.FieldDeadline:
		m.ResetDeadline()
		return nil
	case testplan.FieldStatusUpdatedAt:
		m.ResetStatusUpdatedAt()
		return nil
	case testplan.FieldStatus:
		m.ResetStatus()
		return nil
	case testplan.FieldTasks:
		m.ResetTasks()
		return nil
	case testplan.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown TestPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestPlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestPlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestPlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestPlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestPlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestPlan edge %s", name)
}

// TestcaseMutation represents an operation that mutates the Testcase nodes in the graph.
type TestcaseMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	name          *string
	created_by    *uint32
	addcreated_by *int32
	created_at    *time.Time
	updated_by    *uint32
	addupdated_by *int32
	updated_at    *time.Time
	status        *int8
	addstatus     *int8
	_type         *int8
	add_type      *int8
	priority      *int8
	addpriority   *int8
	deleted_at    *time.Time
	deleted_by    *uint32
	adddeleted_by *int32
	description   *string
	label         *string
	url           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Testcase, error)
	predicates    []predicate.Testcase
}

var _ ent.Mutation = (*TestcaseMutation)(nil)

// testcaseOption allows management of the mutation configuration using functional options.
type testcaseOption func(*TestcaseMutation)

// newTestcaseMutation creates new mutation for the Testcase entity.
func newTestcaseMutation(c config, op Op, opts ...testcaseOption) *TestcaseMutation {
	m := &TestcaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTestcase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestcaseID sets the ID field of the mutation.
func withTestcaseID(id int32) testcaseOption {
	return func(m *TestcaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Testcase
		)
		m.oldValue = func(ctx context.Context) (*Testcase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Testcase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestcase sets the old Testcase of the mutation.
func withTestcase(node *Testcase) testcaseOption {
	return func(m *TestcaseMutation) {
		m.oldValue = func(context.Context) (*Testcase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestcaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestcaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Testcase entities.
func (m *TestcaseMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestcaseMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestcaseMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Testcase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TestcaseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestcaseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestcaseMutation) ResetName() {
	m.name = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TestcaseMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TestcaseMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TestcaseMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TestcaseMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TestcaseMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestcaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestcaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestcaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TestcaseMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TestcaseMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TestcaseMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TestcaseMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TestcaseMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[testcase.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TestcaseMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[testcase.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TestcaseMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, testcase.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestcaseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestcaseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TestcaseMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[testcase.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TestcaseMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[testcase.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestcaseMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, testcase.FieldUpdatedAt)
}

// SetStatus sets the "status" field.
func (m *TestcaseMutation) SetStatus(i int8) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *TestcaseMutation) Status() (r int8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldStatus(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *TestcaseMutation) AddStatus(i int8) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *TestcaseMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *TestcaseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *TestcaseMutation) SetType(i int8) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TestcaseMutation) GetType() (r int8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TestcaseMutation) AddType(i int8) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TestcaseMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TestcaseMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetPriority sets the "priority" field.
func (m *TestcaseMutation) SetPriority(i int8) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TestcaseMutation) Priority() (r int8, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldPriority(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TestcaseMutation) AddPriority(i int8) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TestcaseMutation) AddedPriority() (r int8, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TestcaseMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TestcaseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TestcaseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TestcaseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[testcase.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TestcaseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TestcaseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, testcase.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TestcaseMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TestcaseMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *TestcaseMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *TestcaseMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TestcaseMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[testcase.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TestcaseMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TestcaseMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, testcase.FieldDeletedBy)
}

// SetDescription sets the "description" field.
func (m *TestcaseMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TestcaseMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TestcaseMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[testcase.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TestcaseMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[testcase.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TestcaseMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, testcase.FieldDescription)
}

// SetLabel sets the "label" field.
func (m *TestcaseMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *TestcaseMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ClearLabel clears the value of the "label" field.
func (m *TestcaseMutation) ClearLabel() {
	m.label = nil
	m.clearedFields[testcase.FieldLabel] = struct{}{}
}

// LabelCleared returns if the "label" field was cleared in this mutation.
func (m *TestcaseMutation) LabelCleared() bool {
	_, ok := m.clearedFields[testcase.FieldLabel]
	return ok
}

// ResetLabel resets all changes to the "label" field.
func (m *TestcaseMutation) ResetLabel() {
	m.label = nil
	delete(m.clearedFields, testcase.FieldLabel)
}

// SetURL sets the "url" field.
func (m *TestcaseMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *TestcaseMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Testcase entity.
// If the Testcase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *TestcaseMutation) ClearURL() {
	m.url = nil
	m.clearedFields[testcase.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *TestcaseMutation) URLCleared() bool {
	_, ok := m.clearedFields[testcase.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *TestcaseMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, testcase.FieldURL)
}

// Where appends a list predicates to the TestcaseMutation builder.
func (m *TestcaseMutation) Where(ps ...predicate.Testcase) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestcaseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestcaseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Testcase, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestcaseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestcaseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Testcase).
func (m *TestcaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestcaseMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, testcase.FieldName)
	}
	if m.created_by != nil {
		fields = append(fields, testcase.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, testcase.FieldCreatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, testcase.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, testcase.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, testcase.FieldType)
	}
	if m.priority != nil {
		fields = append(fields, testcase.FieldPriority)
	}
	if m.deleted_at != nil {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, testcase.FieldDeletedBy)
	}
	if m.description != nil {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.label != nil {
		fields = append(fields, testcase.FieldLabel)
	}
	if m.url != nil {
		fields = append(fields, testcase.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestcaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldName:
		return m.Name()
	case testcase.FieldCreatedBy:
		return m.CreatedBy()
	case testcase.FieldCreatedAt:
		return m.CreatedAt()
	case testcase.FieldUpdatedBy:
		return m.UpdatedBy()
	case testcase.FieldUpdatedAt:
		return m.UpdatedAt()
	case testcase.FieldStatus:
		return m.Status()
	case testcase.FieldType:
		return m.GetType()
	case testcase.FieldPriority:
		return m.Priority()
	case testcase.FieldDeletedAt:
		return m.DeletedAt()
	case testcase.FieldDeletedBy:
		return m.DeletedBy()
	case testcase.FieldDescription:
		return m.Description()
	case testcase.FieldLabel:
		return m.Label()
	case testcase.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestcaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcase.FieldName:
		return m.OldName(ctx)
	case testcase.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case testcase.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcase.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case testcase.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testcase.FieldStatus:
		return m.OldStatus(ctx)
	case testcase.FieldType:
		return m.OldType(ctx)
	case testcase.FieldPriority:
		return m.OldPriority(ctx)
	case testcase.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case testcase.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case testcase.FieldDescription:
		return m.OldDescription(ctx)
	case testcase.FieldLabel:
		return m.OldLabel(ctx)
	case testcase.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Testcase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcase.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case testcase.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcase.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case testcase.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testcase.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case testcase.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case testcase.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case testcase.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case testcase.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case testcase.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case testcase.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case testcase.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Testcase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestcaseMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, testcase.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, testcase.FieldUpdatedBy)
	}
	if m.addstatus != nil {
		fields = append(fields, testcase.FieldStatus)
	}
	if m.add_type != nil {
		fields = append(fields, testcase.FieldType)
	}
	if m.addpriority != nil {
		fields = append(fields, testcase.FieldPriority)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, testcase.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestcaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcase.FieldCreatedBy:
		return m.AddedCreatedBy()
	case testcase.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case testcase.FieldStatus:
		return m.AddedStatus()
	case testcase.FieldType:
		return m.AddedType()
	case testcase.FieldPriority:
		return m.AddedPriority()
	case testcase.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcase.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case testcase.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case testcase.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case testcase.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case testcase.FieldPriority:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case testcase.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Testcase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestcaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testcase.FieldUpdatedBy) {
		fields = append(fields, testcase.FieldUpdatedBy)
	}
	if m.FieldCleared(testcase.FieldUpdatedAt) {
		fields = append(fields, testcase.FieldUpdatedAt)
	}
	if m.FieldCleared(testcase.FieldDeletedAt) {
		fields = append(fields, testcase.FieldDeletedAt)
	}
	if m.FieldCleared(testcase.FieldDeletedBy) {
		fields = append(fields, testcase.FieldDeletedBy)
	}
	if m.FieldCleared(testcase.FieldDescription) {
		fields = append(fields, testcase.FieldDescription)
	}
	if m.FieldCleared(testcase.FieldLabel) {
		fields = append(fields, testcase.FieldLabel)
	}
	if m.FieldCleared(testcase.FieldURL) {
		fields = append(fields, testcase.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestcaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestcaseMutation) ClearField(name string) error {
	switch name {
	case testcase.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case testcase.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case testcase.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case testcase.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case testcase.FieldDescription:
		m.ClearDescription()
		return nil
	case testcase.FieldLabel:
		m.ClearLabel()
		return nil
	case testcase.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Testcase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestcaseMutation) ResetField(name string) error {
	switch name {
	case testcase.FieldName:
		m.ResetName()
		return nil
	case testcase.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case testcase.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcase.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case testcase.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testcase.FieldStatus:
		m.ResetStatus()
		return nil
	case testcase.FieldType:
		m.ResetType()
		return nil
	case testcase.FieldPriority:
		m.ResetPriority()
		return nil
	case testcase.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case testcase.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case testcase.FieldDescription:
		m.ResetDescription()
		return nil
	case testcase.FieldLabel:
		m.ResetLabel()
		return nil
	case testcase.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Testcase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestcaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestcaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestcaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestcaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestcaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestcaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestcaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Testcase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestcaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Testcase edge %s", name)
}

// TestcaseSuiteMutation represents an operation that mutates the TestcaseSuite nodes in the graph.
type TestcaseSuiteMutation struct {
	config
	op              Op
	typ             string
	id              *int32
	name            *string
	created_at      *time.Time
	created_by      *uint32
	addcreated_by   *int32
	updated_at      *time.Time
	updated_by      *uint32
	addupdated_by   *int32
	testcases       *[]int32
	appendtestcases []int32
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*TestcaseSuite, error)
	predicates      []predicate.TestcaseSuite
}

var _ ent.Mutation = (*TestcaseSuiteMutation)(nil)

// testcasesuiteOption allows management of the mutation configuration using functional options.
type testcasesuiteOption func(*TestcaseSuiteMutation)

// newTestcaseSuiteMutation creates new mutation for the TestcaseSuite entity.
func newTestcaseSuiteMutation(c config, op Op, opts ...testcasesuiteOption) *TestcaseSuiteMutation {
	m := &TestcaseSuiteMutation{
		config:        c,
		op:            op,
		typ:           TypeTestcaseSuite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTestcaseSuiteID sets the ID field of the mutation.
func withTestcaseSuiteID(id int32) testcasesuiteOption {
	return func(m *TestcaseSuiteMutation) {
		var (
			err   error
			once  sync.Once
			value *TestcaseSuite
		)
		m.oldValue = func(ctx context.Context) (*TestcaseSuite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TestcaseSuite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTestcaseSuite sets the old TestcaseSuite of the mutation.
func withTestcaseSuite(node *TestcaseSuite) testcasesuiteOption {
	return func(m *TestcaseSuiteMutation) {
		m.oldValue = func(context.Context) (*TestcaseSuite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TestcaseSuiteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TestcaseSuiteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TestcaseSuite entities.
func (m *TestcaseSuiteMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TestcaseSuiteMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TestcaseSuiteMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TestcaseSuite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TestcaseSuiteMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TestcaseSuiteMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TestcaseSuiteMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TestcaseSuiteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TestcaseSuiteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TestcaseSuiteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TestcaseSuiteMutation) SetCreatedBy(u uint32) {
	m.created_by = &u
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TestcaseSuiteMutation) CreatedBy() (r uint32, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldCreatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds u to the "created_by" field.
func (m *TestcaseSuiteMutation) AddCreatedBy(u int32) {
	if m.addcreated_by != nil {
		*m.addcreated_by += u
	} else {
		m.addcreated_by = &u
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *TestcaseSuiteMutation) AddedCreatedBy() (r int32, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TestcaseSuiteMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TestcaseSuiteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TestcaseSuiteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TestcaseSuiteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[testcasesuite.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TestcaseSuiteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[testcasesuite.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TestcaseSuiteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, testcasesuite.FieldUpdatedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TestcaseSuiteMutation) SetUpdatedBy(u uint32) {
	m.updated_by = &u
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TestcaseSuiteMutation) UpdatedBy() (r uint32, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldUpdatedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds u to the "updated_by" field.
func (m *TestcaseSuiteMutation) AddUpdatedBy(u int32) {
	if m.addupdated_by != nil {
		*m.addupdated_by += u
	} else {
		m.addupdated_by = &u
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *TestcaseSuiteMutation) AddedUpdatedBy() (r int32, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TestcaseSuiteMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[testcasesuite.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TestcaseSuiteMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[testcasesuite.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TestcaseSuiteMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, testcasesuite.FieldUpdatedBy)
}

// SetTestcases sets the "testcases" field.
func (m *TestcaseSuiteMutation) SetTestcases(i []int32) {
	m.testcases = &i
	m.appendtestcases = nil
}

// Testcases returns the value of the "testcases" field in the mutation.
func (m *TestcaseSuiteMutation) Testcases() (r []int32, exists bool) {
	v := m.testcases
	if v == nil {
		return
	}
	return *v, true
}

// OldTestcases returns the old "testcases" field's value of the TestcaseSuite entity.
// If the TestcaseSuite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TestcaseSuiteMutation) OldTestcases(ctx context.Context) (v []int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestcases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestcases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestcases: %w", err)
	}
	return oldValue.Testcases, nil
}

// AppendTestcases adds i to the "testcases" field.
func (m *TestcaseSuiteMutation) AppendTestcases(i []int32) {
	m.appendtestcases = append(m.appendtestcases, i...)
}

// AppendedTestcases returns the list of values that were appended to the "testcases" field in this mutation.
func (m *TestcaseSuiteMutation) AppendedTestcases() ([]int32, bool) {
	if len(m.appendtestcases) == 0 {
		return nil, false
	}
	return m.appendtestcases, true
}

// ClearTestcases clears the value of the "testcases" field.
func (m *TestcaseSuiteMutation) ClearTestcases() {
	m.testcases = nil
	m.appendtestcases = nil
	m.clearedFields[testcasesuite.FieldTestcases] = struct{}{}
}

// TestcasesCleared returns if the "testcases" field was cleared in this mutation.
func (m *TestcaseSuiteMutation) TestcasesCleared() bool {
	_, ok := m.clearedFields[testcasesuite.FieldTestcases]
	return ok
}

// ResetTestcases resets all changes to the "testcases" field.
func (m *TestcaseSuiteMutation) ResetTestcases() {
	m.testcases = nil
	m.appendtestcases = nil
	delete(m.clearedFields, testcasesuite.FieldTestcases)
}

// Where appends a list predicates to the TestcaseSuiteMutation builder.
func (m *TestcaseSuiteMutation) Where(ps ...predicate.TestcaseSuite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TestcaseSuiteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TestcaseSuiteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TestcaseSuite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TestcaseSuiteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TestcaseSuiteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TestcaseSuite).
func (m *TestcaseSuiteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TestcaseSuiteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, testcasesuite.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, testcasesuite.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, testcasesuite.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, testcasesuite.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, testcasesuite.FieldUpdatedBy)
	}
	if m.testcases != nil {
		fields = append(fields, testcasesuite.FieldTestcases)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TestcaseSuiteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case testcasesuite.FieldName:
		return m.Name()
	case testcasesuite.FieldCreatedAt:
		return m.CreatedAt()
	case testcasesuite.FieldCreatedBy:
		return m.CreatedBy()
	case testcasesuite.FieldUpdatedAt:
		return m.UpdatedAt()
	case testcasesuite.FieldUpdatedBy:
		return m.UpdatedBy()
	case testcasesuite.FieldTestcases:
		return m.Testcases()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TestcaseSuiteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case testcasesuite.FieldName:
		return m.OldName(ctx)
	case testcasesuite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case testcasesuite.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case testcasesuite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case testcasesuite.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case testcasesuite.FieldTestcases:
		return m.OldTestcases(ctx)
	}
	return nil, fmt.Errorf("unknown TestcaseSuite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseSuiteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case testcasesuite.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case testcasesuite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case testcasesuite.FieldCreatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case testcasesuite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case testcasesuite.FieldUpdatedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case testcasesuite.FieldTestcases:
		v, ok := value.([]int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestcases(v)
		return nil
	}
	return fmt.Errorf("unknown TestcaseSuite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TestcaseSuiteMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, testcasesuite.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, testcasesuite.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TestcaseSuiteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case testcasesuite.FieldCreatedBy:
		return m.AddedCreatedBy()
	case testcasesuite.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TestcaseSuiteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case testcasesuite.FieldCreatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case testcasesuite.FieldUpdatedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown TestcaseSuite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TestcaseSuiteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(testcasesuite.FieldUpdatedAt) {
		fields = append(fields, testcasesuite.FieldUpdatedAt)
	}
	if m.FieldCleared(testcasesuite.FieldUpdatedBy) {
		fields = append(fields, testcasesuite.FieldUpdatedBy)
	}
	if m.FieldCleared(testcasesuite.FieldTestcases) {
		fields = append(fields, testcasesuite.FieldTestcases)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TestcaseSuiteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TestcaseSuiteMutation) ClearField(name string) error {
	switch name {
	case testcasesuite.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case testcasesuite.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case testcasesuite.FieldTestcases:
		m.ClearTestcases()
		return nil
	}
	return fmt.Errorf("unknown TestcaseSuite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TestcaseSuiteMutation) ResetField(name string) error {
	switch name {
	case testcasesuite.FieldName:
		m.ResetName()
		return nil
	case testcasesuite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case testcasesuite.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case testcasesuite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case testcasesuite.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case testcasesuite.FieldTestcases:
		m.ResetTestcases()
		return nil
	}
	return fmt.Errorf("unknown TestcaseSuite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TestcaseSuiteMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TestcaseSuiteMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TestcaseSuiteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TestcaseSuiteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TestcaseSuiteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TestcaseSuiteMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TestcaseSuiteMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TestcaseSuite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TestcaseSuiteMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TestcaseSuite edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	uuid            *uuid.UUID
	created_at      *time.Time
	active          *bool
	username        *string
	chineseName     *string
	password        *string
	phone           *string
	email           *string
	avatar          *string
	location        *string
	last_login_time *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	deleted_by      *uint32
	adddeleted_by   *int32
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetChineseName sets the "chineseName" field.
func (m *UserMutation) SetChineseName(s string) {
	m.chineseName = &s
}

// ChineseName returns the value of the "chineseName" field in the mutation.
func (m *UserMutation) ChineseName() (r string, exists bool) {
	v := m.chineseName
	if v == nil {
		return
	}
	return *v, true
}

// OldChineseName returns the old "chineseName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChineseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChineseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChineseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChineseName: %w", err)
	}
	return oldValue.ChineseName, nil
}

// ClearChineseName clears the value of the "chineseName" field.
func (m *UserMutation) ClearChineseName() {
	m.chineseName = nil
	m.clearedFields[user.FieldChineseName] = struct{}{}
}

// ChineseNameCleared returns if the "chineseName" field was cleared in this mutation.
func (m *UserMutation) ChineseNameCleared() bool {
	_, ok := m.clearedFields[user.FieldChineseName]
	return ok
}

// ResetChineseName resets all changes to the "chineseName" field.
func (m *UserMutation) ResetChineseName() {
	m.chineseName = nil
	delete(m.clearedFields, user.FieldChineseName)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// SetLastLoginTime sets the "last_login_time" field.
func (m *UserMutation) SetLastLoginTime(t time.Time) {
	m.last_login_time = &t
}

// LastLoginTime returns the value of the "last_login_time" field in the mutation.
func (m *UserMutation) LastLoginTime() (r time.Time, exists bool) {
	v := m.last_login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginTime returns the old "last_login_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginTime: %w", err)
	}
	return oldValue.LastLoginTime, nil
}

// ClearLastLoginTime clears the value of the "last_login_time" field.
func (m *UserMutation) ClearLastLoginTime() {
	m.last_login_time = nil
	m.clearedFields[user.FieldLastLoginTime] = struct{}{}
}

// LastLoginTimeCleared returns if the "last_login_time" field was cleared in this mutation.
func (m *UserMutation) LastLoginTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginTime]
	return ok
}

// ResetLastLoginTime resets all changes to the "last_login_time" field.
func (m *UserMutation) ResetLastLoginTime() {
	m.last_login_time = nil
	delete(m.clearedFields, user.FieldLastLoginTime)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(u uint32) {
	m.deleted_by = &u
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r uint32, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds u to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(u int32) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += u
	} else {
		m.adddeleted_by = &u
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int32, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.chineseName != nil {
		fields = append(fields, user.FieldChineseName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.last_login_time != nil {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUUID:
		return m.UUID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldActive:
		return m.Active()
	case user.FieldUsername:
		return m.Username()
	case user.FieldChineseName:
		return m.ChineseName()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldEmail:
		return m.Email()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldLocation:
		return m.Location()
	case user.FieldLastLoginTime:
		return m.LastLoginTime()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldChineseName:
		return m.OldChineseName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldLastLoginTime:
		return m.OldLastLoginTime(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldChineseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChineseName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldLastLoginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginTime(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldChineseName) {
		fields = append(fields, user.FieldChineseName)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	if m.FieldCleared(user.FieldLastLoginTime) {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldChineseName:
		m.ClearChineseName()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	case user.FieldLastLoginTime:
		m.ClearLastLoginTime()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldChineseName:
		m.ResetChineseName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldLastLoginTime:
		m.ResetLastLoginTime()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
