// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"galileo/ent/container"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// Container is the model entity for the Container schema.
type Container struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Hostname holds the value of the "hostname" field.
	Hostname string `json:"hostname,omitempty"`
	// Domainname holds the value of the "domainname" field.
	Domainname string `json:"domainname,omitempty"`
	// User holds the value of the "user" field.
	User string `json:"user,omitempty"`
	// Env holds the value of the "env" field.
	Env []string `json:"env,omitempty"`
	// Cmd holds the value of the "cmd" field.
	Cmd []string `json:"cmd,omitempty"`
	// Image holds the value of the "image" field.
	Image string `json:"image,omitempty"`
	// Labels holds the value of the "labels" field.
	Labels []string `json:"labels,omitempty"`
	// Volumes holds the value of the "volumes" field.
	Volumes []string `json:"volumes,omitempty"`
	// WorkingDir holds the value of the "working_dir" field.
	WorkingDir string `json:"working_dir,omitempty"`
	// Entrypoint holds the value of the "entrypoint" field.
	Entrypoint []string `json:"entrypoint,omitempty"`
	// MACAddress holds the value of the "mac_address" field.
	MACAddress string `json:"mac_address,omitempty"`
	// ExposePorts holds the value of the "expose_ports" field.
	ExposePorts []string `json:"expose_ports,omitempty"`
	// ComposeFileURL holds the value of the "compose_file_url" field.
	ComposeFileURL string `json:"compose_file_url,omitempty"`
	// DockerfileURL holds the value of the "dockerfile_url" field.
	DockerfileURL string `json:"dockerfile_url,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Container) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case container.FieldEnv, container.FieldCmd, container.FieldLabels, container.FieldVolumes, container.FieldEntrypoint, container.FieldExposePorts:
			values[i] = new([]byte)
		case container.FieldID, container.FieldHostname, container.FieldDomainname, container.FieldUser, container.FieldImage, container.FieldWorkingDir, container.FieldMACAddress, container.FieldComposeFileURL, container.FieldDockerfileURL:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Container", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Container fields.
func (c *Container) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case container.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				c.ID = value.String
			}
		case container.FieldHostname:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field hostname", values[i])
			} else if value.Valid {
				c.Hostname = value.String
			}
		case container.FieldDomainname:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field domainname", values[i])
			} else if value.Valid {
				c.Domainname = value.String
			}
		case container.FieldUser:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user", values[i])
			} else if value.Valid {
				c.User = value.String
			}
		case container.FieldEnv:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field env", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Env); err != nil {
					return fmt.Errorf("unmarshal field env: %w", err)
				}
			}
		case container.FieldCmd:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field cmd", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Cmd); err != nil {
					return fmt.Errorf("unmarshal field cmd: %w", err)
				}
			}
		case container.FieldImage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field image", values[i])
			} else if value.Valid {
				c.Image = value.String
			}
		case container.FieldLabels:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field labels", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Labels); err != nil {
					return fmt.Errorf("unmarshal field labels: %w", err)
				}
			}
		case container.FieldVolumes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field volumes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Volumes); err != nil {
					return fmt.Errorf("unmarshal field volumes: %w", err)
				}
			}
		case container.FieldWorkingDir:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field working_dir", values[i])
			} else if value.Valid {
				c.WorkingDir = value.String
			}
		case container.FieldEntrypoint:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field entrypoint", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.Entrypoint); err != nil {
					return fmt.Errorf("unmarshal field entrypoint: %w", err)
				}
			}
		case container.FieldMACAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mac_address", values[i])
			} else if value.Valid {
				c.MACAddress = value.String
			}
		case container.FieldExposePorts:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field expose_ports", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &c.ExposePorts); err != nil {
					return fmt.Errorf("unmarshal field expose_ports: %w", err)
				}
			}
		case container.FieldComposeFileURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field compose_file_url", values[i])
			} else if value.Valid {
				c.ComposeFileURL = value.String
			}
		case container.FieldDockerfileURL:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dockerfile_url", values[i])
			} else if value.Valid {
				c.DockerfileURL = value.String
			}
		}
	}
	return nil
}

// Update returns a builder for updating this Container.
// Note that you need to call Container.Unwrap() before calling this method if this Container
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Container) Update() *ContainerUpdateOne {
	return NewContainerClient(c.config).UpdateOne(c)
}

// Unwrap unwraps the Container entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (c *Container) Unwrap() *Container {
	_tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Container is not a transactional entity")
	}
	c.config.driver = _tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Container) String() string {
	var builder strings.Builder
	builder.WriteString("Container(")
	builder.WriteString(fmt.Sprintf("id=%v, ", c.ID))
	builder.WriteString("hostname=")
	builder.WriteString(c.Hostname)
	builder.WriteString(", ")
	builder.WriteString("domainname=")
	builder.WriteString(c.Domainname)
	builder.WriteString(", ")
	builder.WriteString("user=")
	builder.WriteString(c.User)
	builder.WriteString(", ")
	builder.WriteString("env=")
	builder.WriteString(fmt.Sprintf("%v", c.Env))
	builder.WriteString(", ")
	builder.WriteString("cmd=")
	builder.WriteString(fmt.Sprintf("%v", c.Cmd))
	builder.WriteString(", ")
	builder.WriteString("image=")
	builder.WriteString(c.Image)
	builder.WriteString(", ")
	builder.WriteString("labels=")
	builder.WriteString(fmt.Sprintf("%v", c.Labels))
	builder.WriteString(", ")
	builder.WriteString("volumes=")
	builder.WriteString(fmt.Sprintf("%v", c.Volumes))
	builder.WriteString(", ")
	builder.WriteString("working_dir=")
	builder.WriteString(c.WorkingDir)
	builder.WriteString(", ")
	builder.WriteString("entrypoint=")
	builder.WriteString(fmt.Sprintf("%v", c.Entrypoint))
	builder.WriteString(", ")
	builder.WriteString("mac_address=")
	builder.WriteString(c.MACAddress)
	builder.WriteString(", ")
	builder.WriteString("expose_ports=")
	builder.WriteString(fmt.Sprintf("%v", c.ExposePorts))
	builder.WriteString(", ")
	builder.WriteString("compose_file_url=")
	builder.WriteString(c.ComposeFileURL)
	builder.WriteString(", ")
	builder.WriteString("dockerfile_url=")
	builder.WriteString(c.DockerfileURL)
	builder.WriteByte(')')
	return builder.String()
}

// Containers is a parsable slice of Container.
type Containers []*Container
